/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import { fetch, FetcherExtraProps } from './fetcher';
import type * as Schemas from './schemas';
import type * as Responses from './responses';

export type GetUserVariables = FetcherExtraProps;

/**
 * Return details of the user making the request
 */
export const getUser = (variables: GetUserVariables) =>
  fetch<Schemas.UserWithID, undefined, {}, {}, {}>({ url: '/user', method: 'get', ...variables });

export type UpdateUserVariables = {
  body: Schemas.User;
} & FetcherExtraProps;

/**
 * Update user info
 */
export const updateUser = (variables: UpdateUserVariables) =>
  fetch<Schemas.UserWithID, Schemas.User, {}, {}, {}>({ url: '/user', method: 'put', ...variables });

export type DeleteUserVariables = FetcherExtraProps;

/**
 * Delete the user making the request
 */
export const deleteUser = (variables: DeleteUserVariables) =>
  fetch<undefined, undefined, {}, {}, {}>({ url: '/user', method: 'delete', ...variables });

export type GetUserAPIKeysResponse = {
  keys: {
    name: string;
    createdAt: Schemas.DateTime;
  }[];
};

export type GetUserAPIKeysVariables = FetcherExtraProps;

/**
 * Retrieve a list of existing user API keys
 */
export const getUserAPIKeys = (variables: GetUserAPIKeysVariables) =>
  fetch<GetUserAPIKeysResponse, undefined, {}, {}, {}>({ url: '/user/keys', method: 'get', ...variables });

export type CreateUserAPIKeyPathParams = {
  /*
   * API Key name
   */
  keyName: Schemas.APIKeyName;
};

export type CreateUserAPIKeyResponse = {
  name: string;
  key: string;
  createdAt: Schemas.DateTime;
};

export type CreateUserAPIKeyVariables = {
  pathParams: CreateUserAPIKeyPathParams;
} & FetcherExtraProps;

/**
 * Create and return new API key
 */
export const createUserAPIKey = (variables: CreateUserAPIKeyVariables) =>
  fetch<CreateUserAPIKeyResponse, undefined, {}, {}, CreateUserAPIKeyPathParams>({
    url: '/user/keys/{keyName}',
    method: 'post',
    ...variables
  });

export type DeleteUserAPIKeyPathParams = {
  /*
   * API Key name
   */
  keyName: Schemas.APIKeyName;
};

export type DeleteUserAPIKeyVariables = {
  pathParams: DeleteUserAPIKeyPathParams;
} & FetcherExtraProps;

/**
 * Delete an existing API key
 */
export const deleteUserAPIKey = (variables: DeleteUserAPIKeyVariables) =>
  fetch<undefined, undefined, {}, {}, DeleteUserAPIKeyPathParams>({
    url: '/user/keys/{keyName}',
    method: 'delete',
    ...variables
  });

export type CreateWorkspaceVariables = {
  body: Schemas.WorkspaceMeta;
} & FetcherExtraProps;

/**
 * Creates a new workspace with the user requesting it as its single owner.
 */
export const createWorkspace = (variables: CreateWorkspaceVariables) =>
  fetch<Schemas.Workspace, Schemas.WorkspaceMeta, {}, {}, {}>({ url: '/workspaces', method: 'post', ...variables });

export type GetWorkspacesListResponse = {
  workspaces: {
    id: Schemas.WorkspaceID;
    name: string;
    slug: string;
    role: Schemas.Role;
  }[];
};

export type GetWorkspacesListVariables = FetcherExtraProps;

/**
 * Retrieve the list of workspaces the user belongs to
 */
export const getWorkspacesList = (variables: GetWorkspacesListVariables) =>
  fetch<GetWorkspacesListResponse, undefined, {}, {}, {}>({ url: '/workspaces', method: 'get', ...variables });

export type GetWorkspacePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
};

export type GetWorkspaceVariables = {
  pathParams: GetWorkspacePathParams;
} & FetcherExtraProps;

/**
 * Retrieve workspace info from a workspace ID
 */
export const getWorkspace = (variables: GetWorkspaceVariables) =>
  fetch<Schemas.Workspace, undefined, {}, {}, GetWorkspacePathParams>({
    url: '/workspaces/{workspaceId}',
    method: 'get',
    ...variables
  });

export type UpdateWorkspacePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
};

export type UpdateWorkspaceVariables = {
  body: Schemas.WorkspaceMeta;
  pathParams: UpdateWorkspacePathParams;
} & FetcherExtraProps;

/**
 * Update workspace info
 */
export const updateWorkspace = (variables: UpdateWorkspaceVariables) =>
  fetch<Schemas.Workspace, Schemas.WorkspaceMeta, {}, {}, UpdateWorkspacePathParams>({
    url: '/workspaces/{workspaceId}',
    method: 'put',
    ...variables
  });

export type DeleteWorkspacePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
};

export type DeleteWorkspaceVariables = {
  pathParams: DeleteWorkspacePathParams;
} & FetcherExtraProps;

/**
 * Delete the workspace with the provided ID
 */
export const deleteWorkspace = (variables: DeleteWorkspaceVariables) =>
  fetch<undefined, undefined, {}, {}, DeleteWorkspacePathParams>({
    url: '/workspaces/{workspaceId}',
    method: 'delete',
    ...variables
  });

export type GetWorkspaceMembersListPathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
};

export type GetWorkspaceMembersListVariables = {
  pathParams: GetWorkspaceMembersListPathParams;
} & FetcherExtraProps;

/**
 * Retrieve the list of members of the given workspace
 */
export const getWorkspaceMembersList = (variables: GetWorkspaceMembersListVariables) =>
  fetch<Schemas.WorkspaceMembers, undefined, {}, {}, GetWorkspaceMembersListPathParams>({
    url: '/workspaces/{workspaceId}/members',
    method: 'get',
    ...variables
  });

export type UpdateWorkspaceMemberRolePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
  /*
   * UserID
   */
  userId: Schemas.UserID;
};

export type UpdateWorkspaceMemberRoleRequestBody = {
  role: Schemas.Role;
};

export type UpdateWorkspaceMemberRoleVariables = {
  body: UpdateWorkspaceMemberRoleRequestBody;
  pathParams: UpdateWorkspaceMemberRolePathParams;
} & FetcherExtraProps;

/**
 * Update a workspace member role. Workspaces must always have at least one owner, so this operation will fail if trying to remove owner role from the last owner in the workspace.
 */
export const updateWorkspaceMemberRole = (variables: UpdateWorkspaceMemberRoleVariables) =>
  fetch<undefined, UpdateWorkspaceMemberRoleRequestBody, {}, {}, UpdateWorkspaceMemberRolePathParams>({
    url: '/workspaces/{workspaceId}/members/{userId}',
    method: 'put',
    ...variables
  });

export type RemoveWorkspaceMemberPathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
  /*
   * UserID
   */
  userId: Schemas.UserID;
};

export type RemoveWorkspaceMemberVariables = {
  pathParams: RemoveWorkspaceMemberPathParams;
} & FetcherExtraProps;

/**
 * Remove the member from the workspace
 */
export const removeWorkspaceMember = (variables: RemoveWorkspaceMemberVariables) =>
  fetch<undefined, undefined, {}, {}, RemoveWorkspaceMemberPathParams>({
    url: '/workspaces/{workspaceId}/members/{userId}',
    method: 'delete',
    ...variables
  });

export type InviteWorkspaceMemberPathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
};

export type InviteWorkspaceMemberRequestBody = {
  /*
   * @format email
   */
  email: string;
  role: Schemas.Role;
};

export type InviteWorkspaceMemberVariables = {
  body: InviteWorkspaceMemberRequestBody;
  pathParams: InviteWorkspaceMemberPathParams;
} & FetcherExtraProps;

/**
 * Invite some user to join the workspace with the given role
 */
export const inviteWorkspaceMember = (variables: InviteWorkspaceMemberVariables) =>
  fetch<Schemas.WorkspaceInvite, InviteWorkspaceMemberRequestBody, {}, {}, InviteWorkspaceMemberPathParams>({
    url: '/workspaces/{workspaceId}/invites',
    method: 'post',
    ...variables
  });

export type AcceptWorkspaceMemberInvitePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
  /*
   * Invite ID
   */
  inviteKey: Schemas.InviteKey;
};

export type AcceptWorkspaceMemberInviteVariables = {
  pathParams: AcceptWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;

/**
 * Accept the invitation to join a workspace. If the operation succeeds the user will be a member of the workspace
 */
export const acceptWorkspaceMemberInvite = (variables: AcceptWorkspaceMemberInviteVariables) =>
  fetch<undefined, undefined, {}, {}, AcceptWorkspaceMemberInvitePathParams>({
    url: '/workspaces/{workspaceId}/invites/{inviteKey}/accept',
    method: 'post',
    ...variables
  });

export type GetDatabaseListPathParams = {
  workspace: string;
};

export type GetDatabaseListVariables = {
  pathParams: GetDatabaseListPathParams;
} & FetcherExtraProps;

/**
 * List all databases available in your Workspace.
 */
export const getDatabaseList = (variables: GetDatabaseListVariables) =>
  fetch<Schemas.ListDatabasesResponse, undefined, {}, {}, GetDatabaseListPathParams>({
    url: '/dbs',
    method: 'get',
    ...variables
  });

export type GetBranchListPathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type GetBranchListVariables = {
  pathParams: GetBranchListPathParams;
} & FetcherExtraProps;

/**
 * List all available Branches
 */
export const getBranchList = (variables: GetBranchListVariables) =>
  fetch<Schemas.ListBranchesResponse, undefined, {}, {}, GetBranchListPathParams>({
    url: '/dbs/{dbName}',
    method: 'get',
    ...variables
  });

export type CreateDatabasePathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type CreateDatabaseResponse = {
  /*
   * @minLength 1
   */
  databaseName: string;
  branchName?: string;
};

export type CreateDatabaseRequestBody = {
  /*
   * @minLength 1
   */
  displayName?: string;
  /*
   * @minLength 1
   */
  branchName?: string;
  ui?: {
    color?: string;
  };
  metadata?: Schemas.BranchMetadata;
};

export type CreateDatabaseVariables = {
  body?: CreateDatabaseRequestBody;
  pathParams: CreateDatabasePathParams;
} & FetcherExtraProps;

/**
 * Create Database with identifier name
 */
export const createDatabase = (variables: CreateDatabaseVariables) =>
  fetch<CreateDatabaseResponse, CreateDatabaseRequestBody, {}, {}, CreateDatabasePathParams>({
    url: '/dbs/{dbName}',
    method: 'put',
    ...variables
  });

export type DeleteDatabasePathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type DeleteDatabaseVariables = {
  pathParams: DeleteDatabasePathParams;
} & FetcherExtraProps;

/**
 * Delete a database and all of its branches and tables permanently.
 */
export const deleteDatabase = (variables: DeleteDatabaseVariables) =>
  fetch<undefined, undefined, {}, {}, DeleteDatabasePathParams>({
    url: '/dbs/{dbName}',
    method: 'delete',
    ...variables
  });

export type GetBranchDetailsPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchDetailsVariables = {
  pathParams: GetBranchDetailsPathParams;
} & FetcherExtraProps;

export const getBranchDetails = (variables: GetBranchDetailsVariables) =>
  fetch<Schemas.DBBranch, undefined, {}, {}, GetBranchDetailsPathParams>({
    url: '/db/{dbBranchName}',
    method: 'get',
    ...variables
  });

export type CreateBranchPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type CreateBranchQueryParams = {
  /*
   * Name of source branch to branch the new schema from
   */
  from?: string;
};

export type CreateBranchRequestBody = {
  /*
   * Select the branch to fork from. Defaults to 'main'
   */
  from?: string;
  metadata?: Schemas.BranchMetadata;
};

export type CreateBranchVariables = {
  body?: CreateBranchRequestBody;
  pathParams: CreateBranchPathParams;
  queryParams?: CreateBranchQueryParams;
} & FetcherExtraProps;

export const createBranch = (variables: CreateBranchVariables) =>
  fetch<undefined, CreateBranchRequestBody, {}, CreateBranchQueryParams, CreateBranchPathParams>({
    url: '/db/{dbBranchName}',
    method: 'put',
    ...variables
  });

export type DeleteBranchPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type DeleteBranchVariables = {
  pathParams: DeleteBranchPathParams;
} & FetcherExtraProps;

/**
 * Delete the branch in the database and all its resources
 */
export const deleteBranch = (variables: DeleteBranchVariables) =>
  fetch<undefined, undefined, {}, {}, DeleteBranchPathParams>({
    url: '/db/{dbBranchName}',
    method: 'delete',
    ...variables
  });

export type UpdateBranchMetadataPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type UpdateBranchMetadataVariables = {
  body?: Schemas.BranchMetadata;
  pathParams: UpdateBranchMetadataPathParams;
} & FetcherExtraProps;

/**
 * Update the branch metadata
 */
export const updateBranchMetadata = (variables: UpdateBranchMetadataVariables) =>
  fetch<undefined, Schemas.BranchMetadata, {}, {}, UpdateBranchMetadataPathParams>({
    url: '/db/{dbBranchName}/metadata',
    method: 'put',
    ...variables
  });

export type GetBranchMetadataPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchMetadataVariables = {
  pathParams: GetBranchMetadataPathParams;
} & FetcherExtraProps;

export const getBranchMetadata = (variables: GetBranchMetadataVariables) =>
  fetch<Schemas.BranchMetadata, undefined, {}, {}, GetBranchMetadataPathParams>({
    url: '/db/{dbBranchName}/metadata',
    method: 'get',
    ...variables
  });

export type GetBranchMigrationHistoryPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchMigrationHistoryResponse = {
  startedFrom?: Schemas.StartedFromMetadata;
  migrations?: Schemas.BranchMigration[];
};

export type GetBranchMigrationHistoryRequestBody = {
  limit?: number;
  startFrom?: string;
};

export type GetBranchMigrationHistoryVariables = {
  body?: GetBranchMigrationHistoryRequestBody;
  pathParams: GetBranchMigrationHistoryPathParams;
} & FetcherExtraProps;

export const getBranchMigrationHistory = (variables: GetBranchMigrationHistoryVariables) =>
  fetch<
    GetBranchMigrationHistoryResponse,
    GetBranchMigrationHistoryRequestBody,
    {},
    {},
    GetBranchMigrationHistoryPathParams
  >({ url: '/db/{dbBranchName}/migrations', method: 'get', ...variables });

export type ExecuteBranchMigrationPlanPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type ExecuteBranchMigrationPlanRequestBody = {
  version: number;
  migration: Schemas.BranchMigration;
};

export type ExecuteBranchMigrationPlanVariables = {
  body: ExecuteBranchMigrationPlanRequestBody;
  pathParams: ExecuteBranchMigrationPlanPathParams;
} & FetcherExtraProps;

/**
 * Apply a migration plan to the branch
 */
export const executeBranchMigrationPlan = (variables: ExecuteBranchMigrationPlanVariables) =>
  fetch<undefined, ExecuteBranchMigrationPlanRequestBody, {}, {}, ExecuteBranchMigrationPlanPathParams>({
    url: '/db/{dbBranchName}/migrations/execute',
    method: 'post',
    ...variables
  });

export type GetBranchMigrationPlanPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchMigrationPlanVariables = {
  body: Schemas.Schema;
  pathParams: GetBranchMigrationPlanPathParams;
} & FetcherExtraProps;

/**
 * Compute a migration plan from a target schema the branch should be migrated too.
 */
export const getBranchMigrationPlan = (variables: GetBranchMigrationPlanVariables) =>
  fetch<Responses.BranchMigrationPlan, Schemas.Schema, {}, {}, GetBranchMigrationPlanPathParams>({
    url: '/db/{dbBranchName}/migrations/plan',
    method: 'post',
    ...variables
  });

export type GetBranchStatsPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchStatsResponse = {
  timestamp: string;
  interval: string;
  resolution: string;
  numberOfRecords?: Schemas.MetricsDatapoint[];
  writesOverTime?: Schemas.MetricsDatapoint[];
  readsOverTime?: Schemas.MetricsDatapoint[];
  readLatency?: Schemas.MetricsLatency;
  writeLatency?: Schemas.MetricsLatency;
  warning?: string;
};

export type GetBranchStatsVariables = {
  pathParams: GetBranchStatsPathParams;
} & FetcherExtraProps;

/**
 * Get branch usage metrics.
 */
export const getBranchStats = (variables: GetBranchStatsVariables) =>
  fetch<GetBranchStatsResponse, undefined, {}, {}, GetBranchStatsPathParams>({
    url: '/db/{dbBranchName}/stats',
    method: 'get',
    ...variables
  });

export type CreateTablePathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type CreateTableVariables = {
  pathParams: CreateTablePathParams;
} & FetcherExtraProps;

/**
 * Creates a new table with the given name. Returns 422 if a table with the same name already exists.
 */
export const createTable = (variables: CreateTableVariables) =>
  fetch<undefined, undefined, {}, {}, CreateTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}',
    method: 'put',
    ...variables
  });

export type DeleteTablePathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type DeleteTableVariables = {
  pathParams: DeleteTablePathParams;
} & FetcherExtraProps;

/**
 * Deletes the table with the given name.
 */
export const deleteTable = (variables: DeleteTableVariables) =>
  fetch<undefined, undefined, {}, {}, DeleteTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}',
    method: 'delete',
    ...variables
  });

export type UpdateTablePathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type UpdateTableRequestBody = {
  /*
   * @minLength 1
   */
  name: string;
};

export type UpdateTableVariables = {
  body: UpdateTableRequestBody;
  pathParams: UpdateTablePathParams;
} & FetcherExtraProps;

/**
 * Update table. Currently there is only one update operation supported: renaming the table by providing a new name.
 *
 * In the example below, we rename a table from “users” to “people”:
 *
 * ```jsx
 * PATCH /db/test:main/tables/users
 * {
 *   "name": "people"
 * }
 * ```
 */
export const updateTable = (variables: UpdateTableVariables) =>
  fetch<undefined, UpdateTableRequestBody, {}, {}, UpdateTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}',
    method: 'patch',
    ...variables
  });

export type GetTableSchemaPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type GetTableSchemaResponse = {
  columns: Schemas.Column[];
};

export type GetTableSchemaVariables = {
  pathParams: GetTableSchemaPathParams;
} & FetcherExtraProps;

export const getTableSchema = (variables: GetTableSchemaVariables) =>
  fetch<GetTableSchemaResponse, undefined, {}, {}, GetTableSchemaPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/schema',
    method: 'get',
    ...variables
  });

export type SetTableSchemaPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type SetTableSchemaRequestBody = {
  columns: Schemas.Column[];
};

export type SetTableSchemaVariables = {
  body: SetTableSchemaRequestBody;
  pathParams: SetTableSchemaPathParams;
} & FetcherExtraProps;

export const setTableSchema = (variables: SetTableSchemaVariables) =>
  fetch<undefined, SetTableSchemaRequestBody, {}, {}, SetTableSchemaPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/schema',
    method: 'put',
    ...variables
  });

export type GetTableColumnsPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type GetTableColumnsResponse = {
  columns: Schemas.Column[];
};

export type GetTableColumnsVariables = {
  pathParams: GetTableColumnsPathParams;
} & FetcherExtraProps;

/**
 * Retrieves the list of table columns and their definition. This endpoint returns the column list with object columns being reported with their
 * full dot-separated path (flattened).
 */
export const getTableColumns = (variables: GetTableColumnsVariables) =>
  fetch<GetTableColumnsResponse, undefined, {}, {}, GetTableColumnsPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns',
    method: 'get',
    ...variables
  });

export type AddTableColumnPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type AddTableColumnVariables = {
  body: Schemas.Column;
  pathParams: AddTableColumnPathParams;
} & FetcherExtraProps;

/**
 * Adds a new column to the table. The body of the request should contain the column definition. In the column definition, the 'name' field should
 * contain the full path separated by dots. If the parent objects do not exists, they will be automatically created. For example,
 * passing `"name": "address.city"` will auto-create the `address` object if it doesn't exist.
 */
export const addTableColumn = (variables: AddTableColumnVariables) =>
  fetch<Responses.MigrationIdResponse, Schemas.Column, {}, {}, AddTableColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns',
    method: 'post',
    ...variables
  });

export type GetColumnPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Column name
   */
  columnName: Schemas.ColumnName;
  workspace: string;
};

export type GetColumnVariables = {
  pathParams: GetColumnPathParams;
} & FetcherExtraProps;

/**
 * Get the definition of a single column. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
export const getColumn = (variables: GetColumnVariables) =>
  fetch<Schemas.Column, undefined, {}, {}, GetColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',
    method: 'get',
    ...variables
  });

export type DeleteColumnPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Column name
   */
  columnName: Schemas.ColumnName;
  workspace: string;
};

export type DeleteColumnVariables = {
  pathParams: DeleteColumnPathParams;
} & FetcherExtraProps;

/**
 * Deletes the specified column. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
export const deleteColumn = (variables: DeleteColumnVariables) =>
  fetch<Responses.MigrationIdResponse, undefined, {}, {}, DeleteColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',
    method: 'delete',
    ...variables
  });

export type UpdateColumnPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Column name
   */
  columnName: Schemas.ColumnName;
  workspace: string;
};

export type UpdateColumnRequestBody = {
  /*
   * @minLength 1
   */
  name: string;
};

export type UpdateColumnVariables = {
  body: UpdateColumnRequestBody;
  pathParams: UpdateColumnPathParams;
} & FetcherExtraProps;

/**
 * Update column with partial data. Can be used for renaming the column by providing a new "name" field. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
export const updateColumn = (variables: UpdateColumnVariables) =>
  fetch<Responses.MigrationIdResponse, UpdateColumnRequestBody, {}, {}, UpdateColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',
    method: 'patch',
    ...variables
  });

export type InsertRecordPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type InsertRecordResponse = {
  id: string;
  xata: {
    version: number;
  };
};

export type InsertRecordVariables = {
  body?: Record<string, any>;
  pathParams: InsertRecordPathParams;
} & FetcherExtraProps;

/**
 * Insert a new Record into the Table
 */
export const insertRecord = (variables: InsertRecordVariables) =>
  fetch<InsertRecordResponse, Record<string, any>, {}, {}, InsertRecordPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/data',
    method: 'post',
    ...variables
  });

export type InsertRecordWithIDPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type InsertRecordWithIDQueryParams = {
  createOnly?: boolean;
  ifVersion?: number;
};

export type InsertRecordWithIDVariables = {
  body?: Record<string, any>;
  pathParams: InsertRecordWithIDPathParams;
  queryParams?: InsertRecordWithIDQueryParams;
} & FetcherExtraProps;

/**
 * By default, IDs are auto-generated when data is insterted into Xata. Sending a request to this endpoint allows us to insert a record with a pre-existing ID, bypassing the default automatic ID generation.
 */
export const insertRecordWithID = (variables: InsertRecordWithIDVariables) =>
  fetch<
    Responses.RecordUpdateResponse,
    Record<string, any>,
    {},
    InsertRecordWithIDQueryParams,
    InsertRecordWithIDPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'put', ...variables });

export type UpdateRecordWithIDPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type UpdateRecordWithIDQueryParams = {
  ifVersion?: number;
};

export type UpdateRecordWithIDVariables = {
  body?: Record<string, any>;
  pathParams: UpdateRecordWithIDPathParams;
  queryParams?: UpdateRecordWithIDQueryParams;
} & FetcherExtraProps;

export const updateRecordWithID = (variables: UpdateRecordWithIDVariables) =>
  fetch<
    Responses.RecordUpdateResponse,
    Record<string, any>,
    {},
    UpdateRecordWithIDQueryParams,
    UpdateRecordWithIDPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'patch', ...variables });

export type UpsertRecordWithIDPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type UpsertRecordWithIDQueryParams = {
  ifVersion?: number;
};

export type UpsertRecordWithIDVariables = {
  body?: Record<string, any>;
  pathParams: UpsertRecordWithIDPathParams;
  queryParams?: UpsertRecordWithIDQueryParams;
} & FetcherExtraProps;

export const upsertRecordWithID = (variables: UpsertRecordWithIDVariables) =>
  fetch<
    Responses.RecordUpdateResponse,
    Record<string, any>,
    {},
    UpsertRecordWithIDQueryParams,
    UpsertRecordWithIDPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'post', ...variables });

export type DeleteRecordPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type DeleteRecordVariables = {
  pathParams: DeleteRecordPathParams;
} & FetcherExtraProps;

export const deleteRecord = (variables: DeleteRecordVariables) =>
  fetch<undefined, undefined, {}, {}, DeleteRecordPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',
    method: 'delete',
    ...variables
  });

export type GetRecordPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type GetRecordRequestBody = {
  columns?: Schemas.ColumnsFilter;
};

export type GetRecordVariables = {
  body?: GetRecordRequestBody;
  pathParams: GetRecordPathParams;
} & FetcherExtraProps;

/**
 * Retrieve record by ID
 */
export const getRecord = (variables: GetRecordVariables) =>
  fetch<Schemas.XataRecord, GetRecordRequestBody, {}, {}, GetRecordPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',
    method: 'get',
    ...variables
  });

export type BulkInsertTableRecordsPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type BulkInsertTableRecordsResponse = {
  recordIDs: string[];
};

export type BulkInsertTableRecordsRequestBody = {
  records: Record<string, any>[];
};

export type BulkInsertTableRecordsVariables = {
  body: BulkInsertTableRecordsRequestBody;
  pathParams: BulkInsertTableRecordsPathParams;
} & FetcherExtraProps;

/**
 * Bulk insert records
 */
export const bulkInsertTableRecords = (variables: BulkInsertTableRecordsVariables) =>
  fetch<BulkInsertTableRecordsResponse, BulkInsertTableRecordsRequestBody, {}, {}, BulkInsertTableRecordsPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/bulk',
    method: 'post',
    ...variables
  });

export type QueryTablePathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type QueryTableRequestBody = {
  filter?: Schemas.FilterExpression;
  sort?: Schemas.SortExpression;
  page?: Schemas.PageConfig;
  columns?: Schemas.ColumnsFilter;
};

export type QueryTableVariables = {
  body?: QueryTableRequestBody;
  pathParams: QueryTablePathParams;
} & FetcherExtraProps;

/**
 * The Query Table API can be used to retrieve all records in a table.
 * The API support filtering, sorting, selecting a subset of columns, and pagination.
 *
 * The overall structure of the request looks like this:
 *
 * ```json
 * // POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [...],
 *   "filter": {
 *     "$all": [...]
 *     "$any": [...]
 *     ...
 *   },
 *   "sort": {
 *     "multiple": [...]
 *     ...
 *   },
 *   "page": {
 *     ...
 *   }
 * }
 * ```
 *
 * ### Column selection
 *
 * If the `columns` array is not specified, all columns are included. For link
 * fields, only the ID column of the linked records is included in the response.
 *
 * If the `columns` array is specified, only the selected columns are included.
 * The `*` wildcard can be used to select all columns of the given array
 *
 * For objects and link fields, if the column name of the object is specified, we
 * include all of its sub-keys. If only some sub-keys are specified (via dotted
 * notation, e.g. `"settings.plan"` ), then only those sub-keys from the object
 * are included.
 *
 * By the way of example, assuming two tables like this:
 *
 * ```json {"truncate": true}
 * {
 *   "formatVersion": "1.0",
 *   "tables": [
 *     {
 *       "name": "teams",
 *       "columns": [
 *         {
 *           "name": "name",
 *           "type": "string"
 *         },
 *         {
 *           "name": "owner",
 *           "type": "link",
 *           "link": {
 *             "table": "users"
 *           }
 *         }
 *       ]
 *     },
 *     {
 *       "name": "users",
 *       "columns": [
 *         {
 *           "name": "email",
 *           "type": "email"
 *         },
 *         {
 *           "name": "full_name",
 *           "type": "string"
 *         },
 *         {
 *           "name": "address",
 *           "type": "object",
 *           "columns": [
 *             {
 *               "name": "street",
 *               "type": "string"
 *             },
 *             {
 *               "name": "number",
 *               "type": "int"
 *             },
 *             {
 *               "name": "zipcode",
 *               "type": "int"
 *             }
 *           ]
 *         },
 *         {
 *           "name": "team",
 *           "type": "link",
 *           "link": {
 *             "table": "teams"
 *           }
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * A query like this:
 *
 * ```json
 * POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [
 *     "name",
 *     "address.*"
 *   ]
 * }
 * ```
 *
 * returns objects like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   }
 * }
 * ```
 *
 * while a query like this:
 *
 * ```json
 * POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [
 *     "name",
 *     "address.street"
 *   ]
 * }
 * ```
 *
 * returns objects like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "address": {
 *     "street": "New street",
 *   }
 * }
 * ```
 *
 * If you want to return all columns from the main table and selected columns from the linked table, you can do it like this:
 *
 * ```json
 * {
 *   "columns": [
 *     "*",
 *     "team.name"
 *   ]
 * }
 * ```
 *
 * The `"*"` in the above means all columns, including columns of objects. This returns data like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "email": "kilian@gmail.com",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   },
 *   "team": {
 *     "id": "XX",
 *     "xata": {
 *       "version": 0,
 *     },
 *     "name": "first team"
 *   }
 * }
 * ```
 *
 * If you want all columns of the linked table, you can do:
 *
 * ```json
 * {
 *   "columns": [
 *     "*",
 *     "team.*"
 *   ]
 * }
 * ```
 *
 * This returns, for example:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "email": "kilian@gmail.com",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   },
 *   "team": {
 *     "id": "XX",
 *     "xata": {
 *       "version": 0,
 *     },
 *     "name": "first team",
 *     "code": "A1"
 *   }
 * }
 * ```
 *
 * ### Filtering
 *
 * There are two types of operators:
 *
 * - Operators that work on a single column: `$is`, `$contains`, `$pattern`,
 *   `$includes`, `$gt`, etc.
 * - Control operators that combine multiple conditions: `$any`, `$all`, `$not` ,
 *   `$none`, etc.
 *
 * All operators start with an `$` to differentiate them from column names
 * (which are not allowed to start with an underscore).
 *
 * #### Exact matching and control operators
 *
 * Filter by one column:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": "value"
 *   }
 * }
 * ```
 *
 * This is equivalent to using the `$is` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$is": "value"
 *     }
 *   }
 * }
 * ```
 *
 * For example:
 *
 * ```json
 * {
 *   "filter": {
 *       "name": "r2",
 *   }
 * }
 * ```
 *
 * Or:
 *
 * ```json
 * {
 *   "filter": {
 *     "name": {
 *       "$is": "r2"
 *     }
 *   }
 * }
 * ```
 *
 * For objects, both dots and nested versions work:
 *
 * ```json
 * {
 *   "filter": {
 *       "settings.plan": "free",
 *   }
 * }
 * ```
 *
 * ```json
 * {
 *   "filter": {
 *     "settings": {
 *       "plan": "free"
 *     },
 *   },
 * }
 * ```
 *
 * If you want to OR together multiple values, you can use an array of values:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.plan": ["free", "paid"]
 *   },
 * }
 * ```
 *
 * Same query with `$is` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.plan": { "$is": ["free", "paid"]}
 *   },
 * }
 * ```
 *
 * Specifying multiple columns, ANDs them together:
 *
 * ```json
 * {
 *   "filter": {
 *       "settings.dark": true,
 *       "settings.plan": "free",
 *   },
 * }
 * ```
 *
 * To be more explicit about it, you can use `$all` or `$any`:
 *
 * ```json
 * {
 *   "filter": {
 *       "$any": {
 *         "settings.dark": true,
 *         "settings.plan": "free",
 *       }
 *   },
 * }
 * ```
 *
 * `$all` and `$any` can also receive an array of objects, which allows for repeating columns:
 *
 * ```json
 * {
 *   "filter": {
 *     "$any": [
 *       {
 *         "name": "r1",
 *       },
 *       {
 *         "name": "r2",
 *       },
 *     ],
 * }
 * ```
 *
 * You can check for a value being not-null with `$exists`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$exists": "settings",
 *   },
 * }
 * ```
 *
 * This can be combined with `$all` or `$any` :
 *
 * ```json
 * {
 *   "filter": {
 *     "$all": [
 *       {
 *         "$exists": "settings",
 *       },
 *       {
 *         "$exists": "name",
 *       },
 *     ],
 *   }
 * }
 * ```
 *
 * We can also make the negation version, `$notExists` :
 *
 * ```json
 * {
 *   "filter": {
 *     "$notExists": "settings",
 *   },
 * }
 * ```
 *
 * #### Partial match
 *
 * `$contains` is the simplest operator for partial matching. We should generally
 * discourage overusing `$contains` because it typically can't make use of
 * indices.
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$contains": "value"
 *     }
 *   }
 * }
 * ```
 *
 * Wildcards are supported via the `$pattern` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *         "$pattern": "v*alue*"
 *     }
 *   }
 * }
 * ```
 *
 * We could also have `$endsWith` and `$startsWith` operators:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *         "$endsWith": ".gz"
 *     },
 *     "<column_name>": {
 *         "$startsWith": "tmp-"
 *     }
 *   }
 * }
 * ```
 *
 * #### Numeric/date ranges
 *
 * ```json
 * {
 *   "filter": {
 *       "<column_name>": {
 *         "$ge": 0,
 *         "$lt": 100
 *       }
 *   }
 * }
 * ```
 *
 * The supported operators are `$gt`, `$lt`, `$ge`, `$le`.
 *
 * Date ranges would support the same operators, with the date as string in RFC 3339:
 *
 * ```json
 * {
 *   "filter": {
 *       "<column_name>": {
 *         "$gt": "2019-10-12T07:20:50.52Z",
 *         "$lt": "2021-10-12T07:20:50.52Z"
 *       }
 *   }
 * }
 * ```
 *
 * #### Negations
 *
 * A general `$not` operator can inverse any operation.
 *
 * ```json
 * {
 *   "filter": {
 *     "$not": {
 *       "<column_name1>": "value1",
 *       "<column_name2>": "value1"
 *     }
 *   }
 * }
 * ```
 *
 * Note: in the above the two condition are AND together, so this does (NOT ( ...
 * AND ...))
 *
 * Or more complex:
 *
 * ```json
 * {
 *   "filter": {
 *     "$not": {
 *       "$any": [{
 *         "<column_name1>": "value1"
 *       }, {
 *         "$all": [{
 *           "<column_name2>": "value2"
 *         }, {
 *           "<column_name3>": "value3"
 *         }]
 *       }]
 *     }
 *   }
 * }
 * ```
 *
 * The `$not: { $any: {}}` can be shorted using the `$none` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "$none": {
 *       "<column_name1>": "value1",
 *       "<column_name2>": "value1"
 *     }
 *   }
 * }
 * ```
 *
 * In addition, we can add specific operators like `$isNot` to simplify expressions:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$isNot": "2019-10-12T07:20:50.52Z"
 *     }
 *   }
 * }
 * ```
 *
 * #### Working with arrays
 *
 * To test that an array contains a value, use `$includes`.
 *
 * ```json
 * {
 *   "filter": {
 *     "<array_name>": {
 *       "$includes": "value"
 *     }
 *   }
 * }
 * ```
 *
 * The `$includes` operator accepts a custom predicate that will check if any
 * array values matches the predicate. For example a complex predicate can include
 * the `$all` , `$contains` and `$endsWith` operators:
 *
 * ```json
 * {
 *   "filter": {
 *     "<array name>": {
 *       "$includes": {
 *         "$all": [
 *           {"$contains": "label"},
 *           {"$not": {"$endsWith": "-debug"}}
 *         ]
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * The `$includes` all operator succeeds if any column in the array matches the
 * predicate. The `$includesAll` operator succeeds if all array items match the
 * predicate. The `$includesNone` operator succeeds if no array item matches the
 * predicate. The `$includes` operator is a synonym for the `$includesAny`
 * operator.
 *
 * ### Sorting
 *
 * Sorting by one element:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": {
 *     "index": "asc"
 *   }
 * }
 * ```
 *
 * or descendently:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": {
 *     "index": "desc"
 *   }
 * }
 * ```
 *
 * Sorting by multiple fields:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": [
 *     {
 *       "index": "desc"
 *     },
 *     {
 *       "createdAt": "desc"
 *     }
 *   ]
 * }
 * ```
 *
 *
 * ### Pagination
 *
 * We offer cursor pagination and offset pagination. The offset pagination is limited
 * in the amount of data it can retrieve, so we recommend the cursor pagination if you have more than 1000 records.
 *
 * Example of size + offset pagination:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "size": 100,
 *     "offset": 200
 *   }
 * }
 * ```
 *
 * The `page.size` parameter represents the maximum number of records returned by this query. It has a default value of 20 and a maximum value of 200.
 * The `page.offset` parameter represents the number of matching records to skip. It has a default value of 0 and a maximum value of 800.
 *
 * Example of cursor pagination:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "after":"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD"
 *   }
 * }
 * ```
 *
 * In the above example, the value of the `page.after` parameter is the cursor returned by the previous query. A sample response is shown below:
 *
 * ```json
 * {
 *   "meta": {
 *     "page": {
 *       "cursor": "fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD",
 *       "more": true
 *     }
 *   },
 *   "records": [...]
 * }
 * ```
 *
 * The `page` object might contain the follow keys, in addition to `size` and `offset` that were introduced before:
 *
 * - `after`: Return the next page 'after' the current cursor
 * - `before`: Return the previous page 'before' the current cursor.
 * - `first`: Return the first page in the table from a cursor.
 * - `last`: Return the last N records in the table from a cursor, where N is the `page.size` parameter.
 *
 * The request will fail if an invalid cursor value is given to `page.before`,
 * `page.after`, `page.first` , or `page.last`. No other cursor setting can be
 * used if `page.first` or `page.last` is set in a query.
 *
 * If both `page.before` and `page.after` parameters are present we treat the
 * request as a range query. The range query will return all entries after
 * `page.after`, but before `page.before`, up to `page.size` or the maximum
 * page size. This query requires both cursors to use the same filters and sort
 * settings, plus we require `page.after < page.before`. The range query returns
 * a new cursor. If the range encompass multiple pages the next page in the range
 * can be queried by update `page.after` to the returned cursor while keeping the
 * `page.before` cursor from the first range query.
 *
 * The `filter` , `columns`,  `sort` , and `page.size` configuration will be
 * encoded with the cursor.  The pagination request will be invalid if
 * `filter` or `sort` is set. The columns returned and page size can be changed
 * anytime by passing the `columns` or `page.size` settings to the next query.
 *
 * **Special cursors:**
 *
 * - `page.after=end`: Result points past the last entry. The list of records
 *   returned is empty, but `page.meta.cursor` will include a cursor that can be
 *   used to "tail" the table from the end waiting for new data to be inserted.
 * - `page.before=end`: This cursor returns the last page.
 * - `page.first=<cursor>`: Go to first page. This is equivalent to querying the
 *   first page without a cursor but `filter` and `sort` . Yet the `page.first`
 *   cursor can be convenient at times as user code does not need to remember the
 *   filter, sort, columns or page size configuration. All these information are
 *   read from the cursor.
 * - `page.last=<cursor>`: Go to the end of the table. This is equivalent to querying the
 *   last page with `page.before=end`, `filter`, and `sort` . Yet the
 *   `page.last` cursor can be more convenient at times as user code does not
 *   need to remember the filter, sort, columns or page size configuration. All
 *   these information are read from the cursor.
 *
 * When using special cursors like `page.after="end"` or `page.before="end"`, we
 * still allow `filter` and `sort` to be set.
 *
 * Example of getting the last page:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "size": 10,
 *     "before": "end"
 *   }
 * }
 * ```
 */
export const queryTable = (variables: QueryTableVariables) =>
  fetch<Responses.QueryResponse, QueryTableRequestBody, {}, {}, QueryTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/query',
    method: 'post',
    ...variables
  });

export type SearchBranchPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type SearchBranchRequestBody = {
  /*
   * An array with the tables in which to search. By default, all tables are included.
   */
  tables?: string[];
  /*
   * The query string.
   *
   * @minLength 1
   */
  query: string;
  /*
   * Maximum [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) for the search terms. The Levenshtein
   * distance is the number of one charcter changes needed to make two strings equal. The default is 1, meaning that single
   * character typos per word are tollerated by search. You can set it to 0 to remove the typo tollerance or set it to 2
   * to allow two typos in a word.
   *
   * @default 1
   * @maximum 2
   * @minimum 0
   */
  fuzziness?: number;
};

export type SearchBranchVariables = {
  body: SearchBranchRequestBody;
  pathParams: SearchBranchPathParams;
} & FetcherExtraProps;

/**
 * Run a free text search operation across the database branch.
 */
export const searchBranch = (variables: SearchBranchVariables) =>
  fetch<Responses.SearchResponse, SearchBranchRequestBody, {}, {}, SearchBranchPathParams>({
    url: '/db/{dbBranchName}/search',
    method: 'post',
    ...variables
  });

export const operationsByTag = {
  users: { getUser, updateUser, deleteUser, getUserAPIKeys, createUserAPIKey, deleteUserAPIKey },
  workspaces: {
    createWorkspace,
    getWorkspacesList,
    getWorkspace,
    updateWorkspace,
    deleteWorkspace,
    getWorkspaceMembersList,
    updateWorkspaceMemberRole,
    removeWorkspaceMember,
    inviteWorkspaceMember,
    acceptWorkspaceMemberInvite
  },
  database: { getDatabaseList, createDatabase, deleteDatabase },
  branch: {
    getBranchList,
    getBranchDetails,
    createBranch,
    deleteBranch,
    updateBranchMetadata,
    getBranchMetadata,
    getBranchMigrationHistory,
    executeBranchMigrationPlan,
    getBranchMigrationPlan,
    getBranchStats
  },
  table: {
    createTable,
    deleteTable,
    updateTable,
    getTableSchema,
    setTableSchema,
    getTableColumns,
    addTableColumn,
    getColumn,
    deleteColumn,
    updateColumn
  },
  records: {
    insertRecord,
    insertRecordWithID,
    updateRecordWithID,
    upsertRecordWithID,
    deleteRecord,
    getRecord,
    bulkInsertTableRecords,
    queryTable,
    searchBranch
  }
};
