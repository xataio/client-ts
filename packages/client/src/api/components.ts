/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import type * as Fetcher from './fetcher';
import { fetch, FetcherExtraProps } from './fetcher';
import type * as Schemas from './schemas';
import type * as Responses from './responses';

export type GetUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetUserVariables = FetcherExtraProps;

/**
 * Return details of the user making the request
 */
export const getUser = (variables: GetUserVariables, signal?: AbortSignal) =>
  fetch<Schemas.UserWithID, GetUserError, undefined, {}, {}, {}>({ url: '/user', method: 'get', ...variables, signal });

export type UpdateUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateUserVariables = {
  body: Schemas.User;
} & FetcherExtraProps;

/**
 * Update user info
 */
export const updateUser = (variables: UpdateUserVariables, signal?: AbortSignal) =>
  fetch<Schemas.UserWithID, UpdateUserError, Schemas.User, {}, {}, {}>({
    url: '/user',
    method: 'put',
    ...variables,
    signal
  });

export type DeleteUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteUserVariables = FetcherExtraProps;

/**
 * Delete the user making the request
 */
export const deleteUser = (variables: DeleteUserVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteUserError, undefined, {}, {}, {}>({ url: '/user', method: 'delete', ...variables, signal });

export type GetUserAPIKeysError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetUserAPIKeysResponse = {
  keys: {
    name: string;
    createdAt: Schemas.DateTime;
  }[];
};

export type GetUserAPIKeysVariables = FetcherExtraProps;

/**
 * Retrieve a list of existing user API keys
 */
export const getUserAPIKeys = (variables: GetUserAPIKeysVariables, signal?: AbortSignal) =>
  fetch<GetUserAPIKeysResponse, GetUserAPIKeysError, undefined, {}, {}, {}>({
    url: '/user/keys',
    method: 'get',
    ...variables,
    signal
  });

export type CreateUserAPIKeyPathParams = {
  /**
   * API Key name
   */
  keyName: Schemas.APIKeyName;
};

export type CreateUserAPIKeyError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CreateUserAPIKeyResponse = {
  name: string;
  key: string;
  createdAt: Schemas.DateTime;
};

export type CreateUserAPIKeyVariables = {
  pathParams: CreateUserAPIKeyPathParams;
} & FetcherExtraProps;

/**
 * Create and return new API key
 */
export const createUserAPIKey = (variables: CreateUserAPIKeyVariables, signal?: AbortSignal) =>
  fetch<CreateUserAPIKeyResponse, CreateUserAPIKeyError, undefined, {}, {}, CreateUserAPIKeyPathParams>({
    url: '/user/keys/{keyName}',
    method: 'post',
    ...variables,
    signal
  });

export type DeleteUserAPIKeyPathParams = {
  /**
   * API Key name
   */
  keyName: Schemas.APIKeyName;
};

export type DeleteUserAPIKeyError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteUserAPIKeyVariables = {
  pathParams: DeleteUserAPIKeyPathParams;
} & FetcherExtraProps;

/**
 * Delete an existing API key
 */
export const deleteUserAPIKey = (variables: DeleteUserAPIKeyVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteUserAPIKeyError, undefined, {}, {}, DeleteUserAPIKeyPathParams>({
    url: '/user/keys/{keyName}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetWorkspacesListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetWorkspacesListResponse = {
  workspaces: {
    id: Schemas.WorkspaceID;
    name: string;
    slug: string;
    role: Schemas.Role;
  }[];
};

export type GetWorkspacesListVariables = FetcherExtraProps;

/**
 * Retrieve the list of workspaces the user belongs to
 */
export const getWorkspacesList = (variables: GetWorkspacesListVariables, signal?: AbortSignal) =>
  fetch<GetWorkspacesListResponse, GetWorkspacesListError, undefined, {}, {}, {}>({
    url: '/workspaces',
    method: 'get',
    ...variables,
    signal
  });

export type CreateWorkspaceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CreateWorkspaceVariables = {
  body: Schemas.WorkspaceMeta;
} & FetcherExtraProps;

/**
 * Creates a new workspace with the user requesting it as its single owner.
 */
export const createWorkspace = (variables: CreateWorkspaceVariables, signal?: AbortSignal) =>
  fetch<Schemas.Workspace, CreateWorkspaceError, Schemas.WorkspaceMeta, {}, {}, {}>({
    url: '/workspaces',
    method: 'post',
    ...variables,
    signal
  });

export type GetWorkspacePathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
};

export type GetWorkspaceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetWorkspaceVariables = {
  pathParams: GetWorkspacePathParams;
} & FetcherExtraProps;

/**
 * Retrieve workspace info from a workspace ID
 */
export const getWorkspace = (variables: GetWorkspaceVariables, signal?: AbortSignal) =>
  fetch<Schemas.Workspace, GetWorkspaceError, undefined, {}, {}, GetWorkspacePathParams>({
    url: '/workspaces/{workspaceId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateWorkspacePathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
};

export type UpdateWorkspaceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateWorkspaceVariables = {
  body: Schemas.WorkspaceMeta;
  pathParams: UpdateWorkspacePathParams;
} & FetcherExtraProps;

/**
 * Update workspace info
 */
export const updateWorkspace = (variables: UpdateWorkspaceVariables, signal?: AbortSignal) =>
  fetch<Schemas.Workspace, UpdateWorkspaceError, Schemas.WorkspaceMeta, {}, {}, UpdateWorkspacePathParams>({
    url: '/workspaces/{workspaceId}',
    method: 'put',
    ...variables,
    signal
  });

export type DeleteWorkspacePathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
};

export type DeleteWorkspaceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteWorkspaceVariables = {
  pathParams: DeleteWorkspacePathParams;
} & FetcherExtraProps;

/**
 * Delete the workspace with the provided ID
 */
export const deleteWorkspace = (variables: DeleteWorkspaceVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteWorkspaceError, undefined, {}, {}, DeleteWorkspacePathParams>({
    url: '/workspaces/{workspaceId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetWorkspaceMembersListPathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
};

export type GetWorkspaceMembersListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetWorkspaceMembersListVariables = {
  pathParams: GetWorkspaceMembersListPathParams;
} & FetcherExtraProps;

/**
 * Retrieve the list of members of the given workspace
 */
export const getWorkspaceMembersList = (variables: GetWorkspaceMembersListVariables, signal?: AbortSignal) =>
  fetch<Schemas.WorkspaceMembers, GetWorkspaceMembersListError, undefined, {}, {}, GetWorkspaceMembersListPathParams>({
    url: '/workspaces/{workspaceId}/members',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateWorkspaceMemberRolePathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
  /**
   * UserID
   */
  userId: Schemas.UserID;
};

export type UpdateWorkspaceMemberRoleError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateWorkspaceMemberRoleRequestBody = {
  role: Schemas.Role;
};

export type UpdateWorkspaceMemberRoleVariables = {
  body: UpdateWorkspaceMemberRoleRequestBody;
  pathParams: UpdateWorkspaceMemberRolePathParams;
} & FetcherExtraProps;

/**
 * Update a workspace member role. Workspaces must always have at least one owner, so this operation will fail if trying to remove owner role from the last owner in the workspace.
 */
export const updateWorkspaceMemberRole = (variables: UpdateWorkspaceMemberRoleVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    UpdateWorkspaceMemberRoleError,
    UpdateWorkspaceMemberRoleRequestBody,
    {},
    {},
    UpdateWorkspaceMemberRolePathParams
  >({ url: '/workspaces/{workspaceId}/members/{userId}', method: 'put', ...variables, signal });

export type RemoveWorkspaceMemberPathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
  /**
   * UserID
   */
  userId: Schemas.UserID;
};

export type RemoveWorkspaceMemberError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type RemoveWorkspaceMemberVariables = {
  pathParams: RemoveWorkspaceMemberPathParams;
} & FetcherExtraProps;

/**
 * Remove the member from the workspace
 */
export const removeWorkspaceMember = (variables: RemoveWorkspaceMemberVariables, signal?: AbortSignal) =>
  fetch<undefined, RemoveWorkspaceMemberError, undefined, {}, {}, RemoveWorkspaceMemberPathParams>({
    url: '/workspaces/{workspaceId}/members/{userId}',
    method: 'delete',
    ...variables,
    signal
  });

export type InviteWorkspaceMemberPathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
};

export type InviteWorkspaceMemberError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 409;
      payload: Responses.SimpleError;
    }
>;

export type InviteWorkspaceMemberRequestBody = {
  /**
   * @format email
   */
  email: string;
  role: Schemas.Role;
};

export type InviteWorkspaceMemberVariables = {
  body: InviteWorkspaceMemberRequestBody;
  pathParams: InviteWorkspaceMemberPathParams;
} & FetcherExtraProps;

/**
 * Invite some user to join the workspace with the given role
 */
export const inviteWorkspaceMember = (variables: InviteWorkspaceMemberVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkspaceInvite,
    InviteWorkspaceMemberError,
    InviteWorkspaceMemberRequestBody,
    {},
    {},
    InviteWorkspaceMemberPathParams
  >({ url: '/workspaces/{workspaceId}/invites', method: 'post', ...variables, signal });

export type UpdateWorkspaceMemberInvitePathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
  /**
   * Invite identifier
   */
  inviteId: Schemas.InviteID;
};

export type UpdateWorkspaceMemberInviteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type UpdateWorkspaceMemberInviteRequestBody = {
  role: Schemas.Role;
};

export type UpdateWorkspaceMemberInviteVariables = {
  body: UpdateWorkspaceMemberInviteRequestBody;
  pathParams: UpdateWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;

/**
 * This operation provides a way to update an existing invite. Updates are performed in-place; they do not change the invite link, the expiry time, nor do they re-notify the recipient of the invite.
 */
export const updateWorkspaceMemberInvite = (variables: UpdateWorkspaceMemberInviteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkspaceInvite,
    UpdateWorkspaceMemberInviteError,
    UpdateWorkspaceMemberInviteRequestBody,
    {},
    {},
    UpdateWorkspaceMemberInvitePathParams
  >({ url: '/workspaces/{workspaceId}/invites/{inviteId}', method: 'patch', ...variables, signal });

export type CancelWorkspaceMemberInvitePathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
  /**
   * Invite identifier
   */
  inviteId: Schemas.InviteID;
};

export type CancelWorkspaceMemberInviteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CancelWorkspaceMemberInviteVariables = {
  pathParams: CancelWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;

/**
 * This operation provides a way to cancel invites by deleting them. Already accepted invites cannot be deleted.
 */
export const cancelWorkspaceMemberInvite = (variables: CancelWorkspaceMemberInviteVariables, signal?: AbortSignal) =>
  fetch<undefined, CancelWorkspaceMemberInviteError, undefined, {}, {}, CancelWorkspaceMemberInvitePathParams>({
    url: '/workspaces/{workspaceId}/invites/{inviteId}',
    method: 'delete',
    ...variables,
    signal
  });

export type AcceptWorkspaceMemberInvitePathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
  /**
   * Invite Key (secret) for the invited user
   */
  inviteKey: Schemas.InviteKey;
};

export type AcceptWorkspaceMemberInviteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type AcceptWorkspaceMemberInviteVariables = {
  pathParams: AcceptWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;

/**
 * Accept the invitation to join a workspace. If the operation succeeds the user will be a member of the workspace
 */
export const acceptWorkspaceMemberInvite = (variables: AcceptWorkspaceMemberInviteVariables, signal?: AbortSignal) =>
  fetch<undefined, AcceptWorkspaceMemberInviteError, undefined, {}, {}, AcceptWorkspaceMemberInvitePathParams>({
    url: '/workspaces/{workspaceId}/invites/{inviteKey}/accept',
    method: 'post',
    ...variables,
    signal
  });

export type ResendWorkspaceMemberInvitePathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
  /**
   * Invite identifier
   */
  inviteId: Schemas.InviteID;
};

export type ResendWorkspaceMemberInviteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type ResendWorkspaceMemberInviteVariables = {
  pathParams: ResendWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;

/**
 * This operation provides a way to resend an Invite notification. Invite notifications can only be sent for Invites not yet accepted.
 */
export const resendWorkspaceMemberInvite = (variables: ResendWorkspaceMemberInviteVariables, signal?: AbortSignal) =>
  fetch<undefined, ResendWorkspaceMemberInviteError, undefined, {}, {}, ResendWorkspaceMemberInvitePathParams>({
    url: '/workspaces/{workspaceId}/invites/{inviteId}/resend',
    method: 'post',
    ...variables,
    signal
  });

export type GetDatabaseListPathParams = {
  workspace: string;
};

export type GetDatabaseListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type GetDatabaseListVariables = {
  pathParams: GetDatabaseListPathParams;
} & FetcherExtraProps;

/**
 * List all databases available in your Workspace.
 */
export const getDatabaseList = (variables: GetDatabaseListVariables, signal?: AbortSignal) =>
  fetch<Schemas.ListDatabasesResponse, GetDatabaseListError, undefined, {}, {}, GetDatabaseListPathParams>({
    url: '/dbs',
    method: 'get',
    ...variables,
    signal
  });

export type GetBranchListPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type GetBranchListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchListVariables = {
  pathParams: GetBranchListPathParams;
} & FetcherExtraProps;

/**
 * List all available Branches
 */
export const getBranchList = (variables: GetBranchListVariables, signal?: AbortSignal) =>
  fetch<Schemas.ListBranchesResponse, GetBranchListError, undefined, {}, {}, GetBranchListPathParams>({
    url: '/dbs/{dbName}',
    method: 'get',
    ...variables,
    signal
  });

export type CreateDatabasePathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type CreateDatabaseError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type CreateDatabaseResponse = {
  /**
   * @minLength 1
   */
  databaseName: string;
  branchName?: string;
};

export type CreateDatabaseRequestBody = {
  /**
   * @minLength 1
   */
  branchName?: string;
  ui?: {
    color?: string;
  };
  metadata?: Schemas.BranchMetadata;
};

export type CreateDatabaseVariables = {
  body?: CreateDatabaseRequestBody;
  pathParams: CreateDatabasePathParams;
} & FetcherExtraProps;

/**
 * Create Database with identifier name
 */
export const createDatabase = (variables: CreateDatabaseVariables, signal?: AbortSignal) =>
  fetch<CreateDatabaseResponse, CreateDatabaseError, CreateDatabaseRequestBody, {}, {}, CreateDatabasePathParams>({
    url: '/dbs/{dbName}',
    method: 'put',
    ...variables,
    signal
  });

export type DeleteDatabasePathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type DeleteDatabaseError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteDatabaseVariables = {
  pathParams: DeleteDatabasePathParams;
} & FetcherExtraProps;

/**
 * Delete a database and all of its branches and tables permanently.
 */
export const deleteDatabase = (variables: DeleteDatabaseVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteDatabaseError, undefined, {}, {}, DeleteDatabasePathParams>({
    url: '/dbs/{dbName}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetDatabaseMetadataPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type GetDatabaseMetadataError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetDatabaseMetadataVariables = {
  pathParams: GetDatabaseMetadataPathParams;
} & FetcherExtraProps;

/**
 * Retrieve metadata of the given database
 */
export const getDatabaseMetadata = (variables: GetDatabaseMetadataVariables, signal?: AbortSignal) =>
  fetch<Schemas.DatabaseMetadata, GetDatabaseMetadataError, undefined, {}, {}, GetDatabaseMetadataPathParams>({
    url: '/dbs/{dbName}/metadata',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateDatabaseMetadataPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type UpdateDatabaseMetadataError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateDatabaseMetadataRequestBody = {
  ui?: {
    /**
     * @minLength 1
     */
    color?: string;
  };
};

export type UpdateDatabaseMetadataVariables = {
  body?: UpdateDatabaseMetadataRequestBody;
  pathParams: UpdateDatabaseMetadataPathParams;
} & FetcherExtraProps;

/**
 * Update the color of the selected database
 */
export const updateDatabaseMetadata = (variables: UpdateDatabaseMetadataVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.DatabaseMetadata,
    UpdateDatabaseMetadataError,
    UpdateDatabaseMetadataRequestBody,
    {},
    {},
    UpdateDatabaseMetadataPathParams
  >({ url: '/dbs/{dbName}/metadata', method: 'patch', ...variables, signal });

export type GetBranchDetailsPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchDetailsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchDetailsVariables = {
  pathParams: GetBranchDetailsPathParams;
} & FetcherExtraProps;

export const getBranchDetails = (variables: GetBranchDetailsVariables, signal?: AbortSignal) =>
  fetch<Schemas.DBBranch, GetBranchDetailsError, undefined, {}, {}, GetBranchDetailsPathParams>({
    url: '/db/{dbBranchName}',
    method: 'get',
    ...variables,
    signal
  });

export type CreateBranchPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type CreateBranchQueryParams = {
  /**
   * Name of source branch to branch the new schema from
   */
  from?: string;
};

export type CreateBranchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CreateBranchResponse = {
  /**
   * @minLength 1
   */
  databaseName: string;
  branchName: string;
};

export type CreateBranchRequestBody = {
  /**
   * Select the branch to fork from. Defaults to 'main'
   */
  from?: string;
  metadata?: Schemas.BranchMetadata;
};

export type CreateBranchVariables = {
  body?: CreateBranchRequestBody;
  pathParams: CreateBranchPathParams;
  queryParams?: CreateBranchQueryParams;
} & FetcherExtraProps;

export const createBranch = (variables: CreateBranchVariables, signal?: AbortSignal) =>
  fetch<
    CreateBranchResponse,
    CreateBranchError,
    CreateBranchRequestBody,
    {},
    CreateBranchQueryParams,
    CreateBranchPathParams
  >({ url: '/db/{dbBranchName}', method: 'put', ...variables, signal });

export type DeleteBranchPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type DeleteBranchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteBranchVariables = {
  pathParams: DeleteBranchPathParams;
} & FetcherExtraProps;

/**
 * Delete the branch in the database and all its resources
 */
export const deleteBranch = (variables: DeleteBranchVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteBranchError, undefined, {}, {}, DeleteBranchPathParams>({
    url: '/db/{dbBranchName}',
    method: 'delete',
    ...variables,
    signal
  });

export type UpdateBranchMetadataPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type UpdateBranchMetadataError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateBranchMetadataVariables = {
  body?: Schemas.BranchMetadata;
  pathParams: UpdateBranchMetadataPathParams;
} & FetcherExtraProps;

/**
 * Update the branch metadata
 */
export const updateBranchMetadata = (variables: UpdateBranchMetadataVariables, signal?: AbortSignal) =>
  fetch<undefined, UpdateBranchMetadataError, Schemas.BranchMetadata, {}, {}, UpdateBranchMetadataPathParams>({
    url: '/db/{dbBranchName}/metadata',
    method: 'put',
    ...variables,
    signal
  });

export type GetBranchMetadataPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchMetadataError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchMetadataVariables = {
  pathParams: GetBranchMetadataPathParams;
} & FetcherExtraProps;

export const getBranchMetadata = (variables: GetBranchMetadataVariables, signal?: AbortSignal) =>
  fetch<Schemas.BranchMetadata, GetBranchMetadataError, undefined, {}, {}, GetBranchMetadataPathParams>({
    url: '/db/{dbBranchName}/metadata',
    method: 'get',
    ...variables,
    signal
  });

export type GetBranchStatsPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchStatsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.SimpleError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchStatsResponse = {
  timestamp: string;
  interval: string;
  resolution: string;
  numberOfRecords?: Schemas.MetricsDatapoint[];
  writesOverTime?: Schemas.MetricsDatapoint[];
  readsOverTime?: Schemas.MetricsDatapoint[];
  readLatency?: Schemas.MetricsLatency;
  writeLatency?: Schemas.MetricsLatency;
  warning?: string;
};

export type GetBranchStatsVariables = {
  pathParams: GetBranchStatsPathParams;
} & FetcherExtraProps;

/**
 * Get branch usage metrics.
 */
export const getBranchStats = (variables: GetBranchStatsVariables, signal?: AbortSignal) =>
  fetch<GetBranchStatsResponse, GetBranchStatsError, undefined, {}, {}, GetBranchStatsPathParams>({
    url: '/db/{dbBranchName}/stats',
    method: 'get',
    ...variables,
    signal
  });

export type GetGitBranchesMappingPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type GetGitBranchesMappingError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type GetGitBranchesMappingVariables = {
  pathParams: GetGitBranchesMappingPathParams;
} & FetcherExtraProps;

/**
 * Lists all the git branches in the mapping, and their associated Xata branches.
 *
 * Example response:
 *
 * ```json
 * {
 *   "mappings": [
 *       {
 *         "gitBranch": "main",
 *         "xataBranch": "main"
 *       },
 *       {
 *         "gitBranch": "gitBranch1",
 *         "xataBranch": "xataBranch1"
 *       }
 *       {
 *         "gitBranch": "xataBranch2",
 *         "xataBranch": "xataBranch2"
 *       }
 *   ]
 * }
 * ```
 */
export const getGitBranchesMapping = (variables: GetGitBranchesMappingVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ListGitBranchesResponse,
    GetGitBranchesMappingError,
    undefined,
    {},
    {},
    GetGitBranchesMappingPathParams
  >({ url: '/dbs/{dbName}/gitBranches', method: 'get', ...variables, signal });

export type AddGitBranchesEntryPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type AddGitBranchesEntryError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type AddGitBranchesEntryResponse = {
  /**
   * Warning message
   */
  warning?: string;
};

export type AddGitBranchesEntryRequestBody = {
  /**
   * The name of the Git branch.
   */
  gitBranch: string;
  /**
   * The name of the Xata branch.
   */
  xataBranch: Schemas.BranchName;
};

export type AddGitBranchesEntryVariables = {
  body: AddGitBranchesEntryRequestBody;
  pathParams: AddGitBranchesEntryPathParams;
} & FetcherExtraProps;

/**
 * Adds an entry to the mapping of git branches to Xata branches. The git branch and the Xata branch must be present in the body of the request. If the Xata branch doesn't exist, a 400 error is returned.
 *
 * If the git branch is already present in the mapping, the old entry is overwritten, and a warning message is included in the response. If the git branch is added and didn't exist before, the response code is 204. If the git branch existed and it was overwritten, the response code is 201.
 *
 * Example request:
 *
 * ```json
 * // POST https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches
 * {
 *   "gitBranch": "fix/bug123",
 *   "xataBranch": "fix_bug"
 * }
 * ```
 */
export const addGitBranchesEntry = (variables: AddGitBranchesEntryVariables, signal?: AbortSignal) =>
  fetch<
    AddGitBranchesEntryResponse,
    AddGitBranchesEntryError,
    AddGitBranchesEntryRequestBody,
    {},
    {},
    AddGitBranchesEntryPathParams
  >({ url: '/dbs/{dbName}/gitBranches', method: 'post', ...variables, signal });

export type RemoveGitBranchesEntryPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type RemoveGitBranchesEntryQueryParams = {
  /**
   * The Git Branch to remove from the mapping
   */
  gitBranch: string;
};

export type RemoveGitBranchesEntryError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type RemoveGitBranchesEntryVariables = {
  pathParams: RemoveGitBranchesEntryPathParams;
  queryParams: RemoveGitBranchesEntryQueryParams;
} & FetcherExtraProps;

/**
 * Removes an entry from the mapping of git branches to Xata branches. The name of the git branch must be passed as a query parameter. If the git branch is not found, the endpoint returns a 404 status code.
 *
 * Example request:
 *
 * ```json
 * // DELETE https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches?gitBranch=fix%2Fbug123
 * ```
 */
export const removeGitBranchesEntry = (variables: RemoveGitBranchesEntryVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    RemoveGitBranchesEntryError,
    undefined,
    {},
    RemoveGitBranchesEntryQueryParams,
    RemoveGitBranchesEntryPathParams
  >({ url: '/dbs/{dbName}/gitBranches', method: 'delete', ...variables, signal });

export type ResolveBranchPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type ResolveBranchQueryParams = {
  /**
   * The Git Branch
   */
  gitBranch?: string;
  /**
   * Default branch to fallback to
   */
  fallbackBranch?: string;
};

export type ResolveBranchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type ResolveBranchResponse = {
  branch: string;
  reason: {
    code: 'FOUND_IN_MAPPING' | 'BRANCH_EXISTS' | 'FALLBACK_BRANCH' | 'DEFAULT_BRANCH';
    message: string;
  };
};

export type ResolveBranchVariables = {
  pathParams: ResolveBranchPathParams;
  queryParams?: ResolveBranchQueryParams;
} & FetcherExtraProps;

/**
 * In order to resolve the database branch, the following algorithm is used:
 * * if the `gitBranch` was provided and is found in the [git branches mapping](/api-reference/dbs/db_name/gitBranches), the associated Xata branch is returned
 * * else, if a Xata branch with the exact same name as `gitBranch` exists, return it
 * * else, if `fallbackBranch` is provided and a branch with that name exists, return it
 * * else, return the default branch of the DB (`main` or the first branch)
 *
 * Example call:
 *
 * ```json
 * // GET https://tutorial-ng7s8c.xata.sh/dbs/demo/dbs/demo/resolveBranch?gitBranch=test&fallbackBranch=tsg
 * ```
 *
 * Example response:
 *
 * ```json
 * {
 *   "branch": "main",
 *   "reason": {
 *     "code": "DEFAULT_BRANCH",
 *     "message": "Default branch for this database (main)"
 *   }
 * }
 * ```
 */
export const resolveBranch = (variables: ResolveBranchVariables, signal?: AbortSignal) =>
  fetch<ResolveBranchResponse, ResolveBranchError, undefined, {}, ResolveBranchQueryParams, ResolveBranchPathParams>({
    url: '/dbs/{dbName}/resolveBranch',
    method: 'get',
    ...variables,
    signal
  });

export type GetBranchMigrationHistoryPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchMigrationHistoryError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchMigrationHistoryResponse = {
  startedFrom?: Schemas.StartedFromMetadata;
  migrations?: Schemas.BranchMigration[];
};

export type GetBranchMigrationHistoryRequestBody = {
  limit?: number;
  startFrom?: string;
};

export type GetBranchMigrationHistoryVariables = {
  body?: GetBranchMigrationHistoryRequestBody;
  pathParams: GetBranchMigrationHistoryPathParams;
} & FetcherExtraProps;

export const getBranchMigrationHistory = (variables: GetBranchMigrationHistoryVariables, signal?: AbortSignal) =>
  fetch<
    GetBranchMigrationHistoryResponse,
    GetBranchMigrationHistoryError,
    GetBranchMigrationHistoryRequestBody,
    {},
    {},
    GetBranchMigrationHistoryPathParams
  >({ url: '/db/{dbBranchName}/migrations', method: 'get', ...variables, signal });

export type GetBranchMigrationPlanPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchMigrationPlanError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchMigrationPlanVariables = {
  body: Schemas.Schema;
  pathParams: GetBranchMigrationPlanPathParams;
} & FetcherExtraProps;

/**
 * Compute a migration plan from a target schema the branch should be migrated too.
 */
export const getBranchMigrationPlan = (variables: GetBranchMigrationPlanVariables, signal?: AbortSignal) =>
  fetch<
    Responses.BranchMigrationPlan,
    GetBranchMigrationPlanError,
    Schemas.Schema,
    {},
    {},
    GetBranchMigrationPlanPathParams
  >({ url: '/db/{dbBranchName}/migrations/plan', method: 'post', ...variables, signal });

export type ExecuteBranchMigrationPlanPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type ExecuteBranchMigrationPlanError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type ExecuteBranchMigrationPlanRequestBody = {
  version: number;
  migration: Schemas.BranchMigration;
};

export type ExecuteBranchMigrationPlanVariables = {
  body: ExecuteBranchMigrationPlanRequestBody;
  pathParams: ExecuteBranchMigrationPlanPathParams;
} & FetcherExtraProps;

/**
 * Apply a migration plan to the branch
 */
export const executeBranchMigrationPlan = (variables: ExecuteBranchMigrationPlanVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    ExecuteBranchMigrationPlanError,
    ExecuteBranchMigrationPlanRequestBody,
    {},
    {},
    ExecuteBranchMigrationPlanPathParams
  >({ url: '/db/{dbBranchName}/migrations/execute', method: 'post', ...variables, signal });

export type QueryMigrationRequestsPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type QueryMigrationRequestsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type QueryMigrationRequestsResponse = {
  migrationRequests: Schemas.MigrationRequest[];
  meta: Schemas.RecordsMetadata;
};

export type QueryMigrationRequestsRequestBody = {
  filter?: Schemas.FilterExpression;
  sort?: Schemas.SortExpression;
  page?: Schemas.PageConfig;
  columns?: Schemas.ColumnsProjection;
};

export type QueryMigrationRequestsVariables = {
  body?: QueryMigrationRequestsRequestBody;
  pathParams: QueryMigrationRequestsPathParams;
} & FetcherExtraProps;

export const queryMigrationRequests = (variables: QueryMigrationRequestsVariables, signal?: AbortSignal) =>
  fetch<
    QueryMigrationRequestsResponse,
    QueryMigrationRequestsError,
    QueryMigrationRequestsRequestBody,
    {},
    {},
    QueryMigrationRequestsPathParams
  >({ url: '/dbs/{dbName}/migrations/query', method: 'post', ...variables, signal });

export type CreateMigrationRequestPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type CreateMigrationRequestError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CreateMigrationRequestResponse = {
  number: number;
};

export type CreateMigrationRequestRequestBody = {
  /**
   * The source branch.
   */
  source: string;
  /**
   * The target branch.
   */
  target: string;
  /**
   * The title.
   */
  title: string;
  /**
   * Optional migration request description.
   */
  body?: string;
};

export type CreateMigrationRequestVariables = {
  body: CreateMigrationRequestRequestBody;
  pathParams: CreateMigrationRequestPathParams;
} & FetcherExtraProps;

export const createMigrationRequest = (variables: CreateMigrationRequestVariables, signal?: AbortSignal) =>
  fetch<
    CreateMigrationRequestResponse,
    CreateMigrationRequestError,
    CreateMigrationRequestRequestBody,
    {},
    {},
    CreateMigrationRequestPathParams
  >({ url: '/dbs/{dbName}/migrations', method: 'post', ...variables, signal });

export type GetMigrationRequestPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  /**
   * The migration request number.
   */
  mrNumber: number;
  workspace: string;
};

export type GetMigrationRequestError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetMigrationRequestVariables = {
  pathParams: GetMigrationRequestPathParams;
} & FetcherExtraProps;

export const getMigrationRequest = (variables: GetMigrationRequestVariables, signal?: AbortSignal) =>
  fetch<Schemas.MigrationRequest, GetMigrationRequestError, undefined, {}, {}, GetMigrationRequestPathParams>({
    url: '/dbs/{dbName}/migrations/{mrNumber}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateMigrationRequestPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  /**
   * The migration request number.
   */
  mrNumber: number;
  workspace: string;
};

export type UpdateMigrationRequestError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateMigrationRequestRequestBody = {
  /**
   * New migration request title.
   */
  title?: string;
  /**
   * New migration request description.
   */
  body?: string;
  /**
   * Change the migration request status.
   */
  status?: 'open' | 'closed';
};

export type UpdateMigrationRequestVariables = {
  body?: UpdateMigrationRequestRequestBody;
  pathParams: UpdateMigrationRequestPathParams;
} & FetcherExtraProps;

export const updateMigrationRequest = (variables: UpdateMigrationRequestVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    UpdateMigrationRequestError,
    UpdateMigrationRequestRequestBody,
    {},
    {},
    UpdateMigrationRequestPathParams
  >({ url: '/dbs/{dbName}/migrations/{mrNumber}', method: 'patch', ...variables, signal });

export type ListMigrationRequestsCommitsPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  /**
   * The migration request number.
   */
  mrNumber: number;
  workspace: string;
};

export type ListMigrationRequestsCommitsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type ListMigrationRequestsCommitsResponse = {
  meta: {
    /**
     * last record id
     */
    cursor: string;
    /**
     * true if more records can be fetch
     */
    more: boolean;
  };
  logs: Schemas.Commit[];
};

export type ListMigrationRequestsCommitsRequestBody = {
  page?: {
    /**
     * Query the next page that follow the cursor.
     */
    after?: string;
    /**
     * Query the previous page before the cursor.
     */
    before?: string;
    /**
     * Set page size. If the size is missing it is read from the cursor. If no cursor is given xata will choose the default page size.
     *
     * @default 20
     */
    size?: number;
  };
};

export type ListMigrationRequestsCommitsVariables = {
  body?: ListMigrationRequestsCommitsRequestBody;
  pathParams: ListMigrationRequestsCommitsPathParams;
} & FetcherExtraProps;

export const listMigrationRequestsCommits = (variables: ListMigrationRequestsCommitsVariables, signal?: AbortSignal) =>
  fetch<
    ListMigrationRequestsCommitsResponse,
    ListMigrationRequestsCommitsError,
    ListMigrationRequestsCommitsRequestBody,
    {},
    {},
    ListMigrationRequestsCommitsPathParams
  >({ url: '/dbs/{dbName}/migrations/{mrNumber}/commits', method: 'post', ...variables, signal });

export type CompareMigrationRequestPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  /**
   * The migration request number.
   */
  mrNumber: number;
  workspace: string;
};

export type CompareMigrationRequestError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CompareMigrationRequestVariables = {
  pathParams: CompareMigrationRequestPathParams;
} & FetcherExtraProps;

export const compareMigrationRequest = (variables: CompareMigrationRequestVariables, signal?: AbortSignal) =>
  fetch<
    Responses.SchemaCompareResponse,
    CompareMigrationRequestError,
    undefined,
    {},
    {},
    CompareMigrationRequestPathParams
  >({ url: '/dbs/{dbName}/migrations/{mrNumber}/compare', method: 'post', ...variables, signal });

export type GetMigrationRequestIsMergedPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  /**
   * The migration request number.
   */
  mrNumber: number;
  workspace: string;
};

export type GetMigrationRequestIsMergedError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetMigrationRequestIsMergedResponse = {
  merged?: boolean;
};

export type GetMigrationRequestIsMergedVariables = {
  pathParams: GetMigrationRequestIsMergedPathParams;
} & FetcherExtraProps;

export const getMigrationRequestIsMerged = (variables: GetMigrationRequestIsMergedVariables, signal?: AbortSignal) =>
  fetch<
    GetMigrationRequestIsMergedResponse,
    GetMigrationRequestIsMergedError,
    undefined,
    {},
    {},
    GetMigrationRequestIsMergedPathParams
  >({ url: '/dbs/{dbName}/migrations/{mrNumber}/merge', method: 'get', ...variables, signal });

export type MergeMigrationRequestPathParams = {
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
  /**
   * The migration request number.
   */
  mrNumber: number;
  workspace: string;
};

export type MergeMigrationRequestError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type MergeMigrationRequestVariables = {
  pathParams: MergeMigrationRequestPathParams;
} & FetcherExtraProps;

export const mergeMigrationRequest = (variables: MergeMigrationRequestVariables, signal?: AbortSignal) =>
  fetch<Schemas.Commit, MergeMigrationRequestError, undefined, {}, {}, MergeMigrationRequestPathParams>({
    url: '/dbs/{dbName}/migrations/{mrNumber}/merge',
    method: 'post',
    ...variables,
    signal
  });

export type GetBranchSchemaHistoryPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchSchemaHistoryError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchSchemaHistoryResponse = {
  meta: {
    /**
     * last record id
     */
    cursor: string;
    /**
     * true if more records can be fetch
     */
    more: boolean;
  };
  logs: Schemas.Commit[];
};

export type GetBranchSchemaHistoryRequestBody = {
  page?: {
    /**
     * Query the next page that follow the cursor.
     */
    after?: string;
    /**
     * Query the previous page before the cursor.
     */
    before?: string;
    /**
     * Set page size. If the size is missing it is read from the cursor. If no cursor is given xata will choose the default page size.
     *
     * @default 20
     */
    size?: number;
  };
};

export type GetBranchSchemaHistoryVariables = {
  body?: GetBranchSchemaHistoryRequestBody;
  pathParams: GetBranchSchemaHistoryPathParams;
} & FetcherExtraProps;

export const getBranchSchemaHistory = (variables: GetBranchSchemaHistoryVariables, signal?: AbortSignal) =>
  fetch<
    GetBranchSchemaHistoryResponse,
    GetBranchSchemaHistoryError,
    GetBranchSchemaHistoryRequestBody,
    {},
    {},
    GetBranchSchemaHistoryPathParams
  >({ url: '/db/{dbBranchName}/schema/history', method: 'post', ...variables, signal });

export type CompareBranchWithUserSchemaPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type CompareBranchWithUserSchemaError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CompareBranchWithUserSchemaRequestBody = {
  schema: Schemas.Schema;
};

export type CompareBranchWithUserSchemaVariables = {
  body: CompareBranchWithUserSchemaRequestBody;
  pathParams: CompareBranchWithUserSchemaPathParams;
} & FetcherExtraProps;

export const compareBranchWithUserSchema = (variables: CompareBranchWithUserSchemaVariables, signal?: AbortSignal) =>
  fetch<
    Responses.SchemaCompareResponse,
    CompareBranchWithUserSchemaError,
    CompareBranchWithUserSchemaRequestBody,
    {},
    {},
    CompareBranchWithUserSchemaPathParams
  >({ url: '/db/{dbBranchName}/schema/compare', method: 'post', ...variables, signal });

export type CompareBranchSchemasPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Database Name
   */
  branchName: Schemas.BranchName;
  workspace: string;
};

export type CompareBranchSchemasError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CompareBranchSchemasVariables = {
  body?: Record<string, any>;
  pathParams: CompareBranchSchemasPathParams;
} & FetcherExtraProps;

export const compareBranchSchemas = (variables: CompareBranchSchemasVariables, signal?: AbortSignal) =>
  fetch<
    Responses.SchemaCompareResponse,
    CompareBranchSchemasError,
    Record<string, any>,
    {},
    {},
    CompareBranchSchemasPathParams
  >({ url: '/db/{dbBranchName}/schema/compare/{branchName}', method: 'post', ...variables, signal });

export type UpdateBranchSchemaPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type UpdateBranchSchemaError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateBranchSchemaResponse = {
  id: string;
  parentID: string;
};

export type UpdateBranchSchemaVariables = {
  body: Schemas.Migration;
  pathParams: UpdateBranchSchemaPathParams;
} & FetcherExtraProps;

export const updateBranchSchema = (variables: UpdateBranchSchemaVariables, signal?: AbortSignal) =>
  fetch<UpdateBranchSchemaResponse, UpdateBranchSchemaError, Schemas.Migration, {}, {}, UpdateBranchSchemaPathParams>({
    url: '/db/{dbBranchName}/schema/update',
    method: 'post',
    ...variables,
    signal
  });

export type PreviewBranchSchemaEditPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type PreviewBranchSchemaEditError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type PreviewBranchSchemaEditResponse = {
  original: Schemas.Schema;
  updated: Schemas.Schema;
};

export type PreviewBranchSchemaEditRequestBody = {
  edits?: Schemas.SchemaEditScript;
  operations?: Schemas.MigrationOp[];
};

export type PreviewBranchSchemaEditVariables = {
  body?: PreviewBranchSchemaEditRequestBody;
  pathParams: PreviewBranchSchemaEditPathParams;
} & FetcherExtraProps;

export const previewBranchSchemaEdit = (variables: PreviewBranchSchemaEditVariables, signal?: AbortSignal) =>
  fetch<
    PreviewBranchSchemaEditResponse,
    PreviewBranchSchemaEditError,
    PreviewBranchSchemaEditRequestBody,
    {},
    {},
    PreviewBranchSchemaEditPathParams
  >({ url: '/db/{dbBranchName}/schema/preview', method: 'post', ...variables, signal });

export type ApplyBranchSchemaEditPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type ApplyBranchSchemaEditError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type ApplyBranchSchemaEditResponse = {
  id: string;
  parentID: string;
};

export type ApplyBranchSchemaEditRequestBody = {
  edits: Schemas.SchemaEditScript;
};

export type ApplyBranchSchemaEditVariables = {
  body: ApplyBranchSchemaEditRequestBody;
  pathParams: ApplyBranchSchemaEditPathParams;
} & FetcherExtraProps;

export const applyBranchSchemaEdit = (variables: ApplyBranchSchemaEditVariables, signal?: AbortSignal) =>
  fetch<
    ApplyBranchSchemaEditResponse,
    ApplyBranchSchemaEditError,
    ApplyBranchSchemaEditRequestBody,
    {},
    {},
    ApplyBranchSchemaEditPathParams
  >({ url: '/db/{dbBranchName}/schema/apply', method: 'post', ...variables, signal });

export type CreateTablePathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type CreateTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type CreateTableResponse = {
  branchName: string;
  /**
   * @minLength 1
   */
  tableName: string;
};

export type CreateTableVariables = {
  pathParams: CreateTablePathParams;
} & FetcherExtraProps;

/**
 * Creates a new table with the given name. Returns 422 if a table with the same name already exists.
 */
export const createTable = (variables: CreateTableVariables, signal?: AbortSignal) =>
  fetch<CreateTableResponse, CreateTableError, undefined, {}, {}, CreateTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}',
    method: 'put',
    ...variables,
    signal
  });

export type DeleteTablePathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type DeleteTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type DeleteTableVariables = {
  pathParams: DeleteTablePathParams;
} & FetcherExtraProps;

/**
 * Deletes the table with the given name.
 */
export const deleteTable = (variables: DeleteTableVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteTableError, undefined, {}, {}, DeleteTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}',
    method: 'delete',
    ...variables,
    signal
  });

export type UpdateTablePathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type UpdateTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateTableRequestBody = {
  /**
   * @minLength 1
   */
  name: string;
};

export type UpdateTableVariables = {
  body: UpdateTableRequestBody;
  pathParams: UpdateTablePathParams;
} & FetcherExtraProps;

/**
 * Update table. Currently there is only one update operation supported: renaming the table by providing a new name.
 *
 * In the example below, we rename a table from “users” to “people”:
 *
 * ```json
 * // PATCH /db/test:main/tables/users
 *
 * {
 *   "name": "people"
 * }
 * ```
 */
export const updateTable = (variables: UpdateTableVariables, signal?: AbortSignal) =>
  fetch<undefined, UpdateTableError, UpdateTableRequestBody, {}, {}, UpdateTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}',
    method: 'patch',
    ...variables,
    signal
  });

export type GetTableSchemaPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type GetTableSchemaError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetTableSchemaResponse = {
  columns: Schemas.Column[];
};

export type GetTableSchemaVariables = {
  pathParams: GetTableSchemaPathParams;
} & FetcherExtraProps;

export const getTableSchema = (variables: GetTableSchemaVariables, signal?: AbortSignal) =>
  fetch<GetTableSchemaResponse, GetTableSchemaError, undefined, {}, {}, GetTableSchemaPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/schema',
    method: 'get',
    ...variables,
    signal
  });

export type SetTableSchemaPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type SetTableSchemaError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 409;
      payload: Responses.SimpleError;
    }
>;

export type SetTableSchemaRequestBody = {
  columns: Schemas.Column[];
};

export type SetTableSchemaVariables = {
  body: SetTableSchemaRequestBody;
  pathParams: SetTableSchemaPathParams;
} & FetcherExtraProps;

export const setTableSchema = (variables: SetTableSchemaVariables, signal?: AbortSignal) =>
  fetch<undefined, SetTableSchemaError, SetTableSchemaRequestBody, {}, {}, SetTableSchemaPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/schema',
    method: 'put',
    ...variables,
    signal
  });

export type GetTableColumnsPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type GetTableColumnsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetTableColumnsResponse = {
  columns: Schemas.Column[];
};

export type GetTableColumnsVariables = {
  pathParams: GetTableColumnsPathParams;
} & FetcherExtraProps;

/**
 * Retrieves the list of table columns and their definition. This endpoint returns the column list with object columns being reported with their
 * full dot-separated path (flattened).
 */
export const getTableColumns = (variables: GetTableColumnsVariables, signal?: AbortSignal) =>
  fetch<GetTableColumnsResponse, GetTableColumnsError, undefined, {}, {}, GetTableColumnsPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns',
    method: 'get',
    ...variables,
    signal
  });

export type AddTableColumnPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type AddTableColumnError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type AddTableColumnVariables = {
  body: Schemas.Column;
  pathParams: AddTableColumnPathParams;
} & FetcherExtraProps;

/**
 * Adds a new column to the table. The body of the request should contain the column definition. In the column definition, the 'name' field should
 * contain the full path separated by dots. If the parent objects do not exists, they will be automatically created. For example,
 * passing `"name": "address.city"` will auto-create the `address` object if it doesn't exist.
 */
export const addTableColumn = (variables: AddTableColumnVariables, signal?: AbortSignal) =>
  fetch<Responses.MigrationIdResponse, AddTableColumnError, Schemas.Column, {}, {}, AddTableColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns',
    method: 'post',
    ...variables,
    signal
  });

export type GetColumnPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  /**
   * The Column name
   */
  columnName: Schemas.ColumnName;
  workspace: string;
};

export type GetColumnError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetColumnVariables = {
  pathParams: GetColumnPathParams;
} & FetcherExtraProps;

/**
 * Get the definition of a single column. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
export const getColumn = (variables: GetColumnVariables, signal?: AbortSignal) =>
  fetch<Schemas.Column, GetColumnError, undefined, {}, {}, GetColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateColumnPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  /**
   * The Column name
   */
  columnName: Schemas.ColumnName;
  workspace: string;
};

export type UpdateColumnError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateColumnRequestBody = {
  /**
   * @minLength 1
   */
  name: string;
};

export type UpdateColumnVariables = {
  body: UpdateColumnRequestBody;
  pathParams: UpdateColumnPathParams;
} & FetcherExtraProps;

/**
 * Update column with partial data. Can be used for renaming the column by providing a new "name" field. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
export const updateColumn = (variables: UpdateColumnVariables, signal?: AbortSignal) =>
  fetch<Responses.MigrationIdResponse, UpdateColumnError, UpdateColumnRequestBody, {}, {}, UpdateColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',
    method: 'patch',
    ...variables,
    signal
  });

export type DeleteColumnPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  /**
   * The Column name
   */
  columnName: Schemas.ColumnName;
  workspace: string;
};

export type DeleteColumnError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteColumnVariables = {
  pathParams: DeleteColumnPathParams;
} & FetcherExtraProps;

/**
 * Deletes the specified column. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
export const deleteColumn = (variables: DeleteColumnVariables, signal?: AbortSignal) =>
  fetch<Responses.MigrationIdResponse, DeleteColumnError, undefined, {}, {}, DeleteColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',
    method: 'delete',
    ...variables,
    signal
  });

export type InsertRecordPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type InsertRecordQueryParams = {
  /**
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
};

export type InsertRecordError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type InsertRecordVariables = {
  body?: Record<string, any>;
  pathParams: InsertRecordPathParams;
  queryParams?: InsertRecordQueryParams;
} & FetcherExtraProps;

/**
 * Insert a new Record into the Table
 */
export const insertRecord = (variables: InsertRecordVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RecordUpdateResponse,
    InsertRecordError,
    Record<string, any>,
    {},
    InsertRecordQueryParams,
    InsertRecordPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data', method: 'post', ...variables, signal });

export type GetRecordPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  /**
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type GetRecordQueryParams = {
  /**
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
};

export type GetRecordError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetRecordVariables = {
  pathParams: GetRecordPathParams;
  queryParams?: GetRecordQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve record by ID
 */
export const getRecord = (variables: GetRecordVariables, signal?: AbortSignal) =>
  fetch<Responses.RecordResponse, GetRecordError, undefined, {}, GetRecordQueryParams, GetRecordPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',
    method: 'get',
    ...variables,
    signal
  });

export type InsertRecordWithIDPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  /**
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type InsertRecordWithIDQueryParams = {
  /**
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
  createOnly?: boolean;
  ifVersion?: number;
};

export type InsertRecordWithIDError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type InsertRecordWithIDVariables = {
  body?: Record<string, any>;
  pathParams: InsertRecordWithIDPathParams;
  queryParams?: InsertRecordWithIDQueryParams;
} & FetcherExtraProps;

/**
 * By default, IDs are auto-generated when data is insterted into Xata. Sending a request to this endpoint allows us to insert a record with a pre-existing ID, bypassing the default automatic ID generation.
 */
export const insertRecordWithID = (variables: InsertRecordWithIDVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RecordUpdateResponse,
    InsertRecordWithIDError,
    Record<string, any>,
    {},
    InsertRecordWithIDQueryParams,
    InsertRecordWithIDPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'put', ...variables, signal });

export type UpdateRecordWithIDPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  /**
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type UpdateRecordWithIDQueryParams = {
  /**
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
  ifVersion?: number;
};

export type UpdateRecordWithIDError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type UpdateRecordWithIDVariables = {
  body?: Record<string, any>;
  pathParams: UpdateRecordWithIDPathParams;
  queryParams?: UpdateRecordWithIDQueryParams;
} & FetcherExtraProps;

export const updateRecordWithID = (variables: UpdateRecordWithIDVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RecordUpdateResponse,
    UpdateRecordWithIDError,
    Record<string, any>,
    {},
    UpdateRecordWithIDQueryParams,
    UpdateRecordWithIDPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'patch', ...variables, signal });

export type UpsertRecordWithIDPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  /**
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type UpsertRecordWithIDQueryParams = {
  /**
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
  ifVersion?: number;
};

export type UpsertRecordWithIDError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type UpsertRecordWithIDVariables = {
  body?: Record<string, any>;
  pathParams: UpsertRecordWithIDPathParams;
  queryParams?: UpsertRecordWithIDQueryParams;
} & FetcherExtraProps;

export const upsertRecordWithID = (variables: UpsertRecordWithIDVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RecordUpdateResponse,
    UpsertRecordWithIDError,
    Record<string, any>,
    {},
    UpsertRecordWithIDQueryParams,
    UpsertRecordWithIDPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'post', ...variables, signal });

export type DeleteRecordPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  /**
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type DeleteRecordQueryParams = {
  /**
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
};

export type DeleteRecordError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteRecordVariables = {
  pathParams: DeleteRecordPathParams;
  queryParams?: DeleteRecordQueryParams;
} & FetcherExtraProps;

export const deleteRecord = (variables: DeleteRecordVariables, signal?: AbortSignal) =>
  fetch<Responses.RecordResponse, DeleteRecordError, undefined, {}, DeleteRecordQueryParams, DeleteRecordPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',
    method: 'delete',
    ...variables,
    signal
  });

export type BulkInsertTableRecordsPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type BulkInsertTableRecordsQueryParams = {
  /**
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
};

export type BulkInsertTableRecordsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BulkError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type BulkInsertTableRecordsRequestBody = {
  records: Record<string, any>[];
};

export type BulkInsertTableRecordsVariables = {
  body: BulkInsertTableRecordsRequestBody;
  pathParams: BulkInsertTableRecordsPathParams;
  queryParams?: BulkInsertTableRecordsQueryParams;
} & FetcherExtraProps;

/**
 * Bulk insert records
 */
export const bulkInsertTableRecords = (variables: BulkInsertTableRecordsVariables, signal?: AbortSignal) =>
  fetch<
    Responses.BulkInsertResponse,
    BulkInsertTableRecordsError,
    BulkInsertTableRecordsRequestBody,
    {},
    BulkInsertTableRecordsQueryParams,
    BulkInsertTableRecordsPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/bulk', method: 'post', ...variables, signal });

export type QueryTablePathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type QueryTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type QueryTableRequestBody = {
  filter?: Schemas.FilterExpression;
  sort?: Schemas.SortExpression;
  page?: Schemas.PageConfig;
  columns?: Schemas.ColumnsProjection;
};

export type QueryTableVariables = {
  body?: QueryTableRequestBody;
  pathParams: QueryTablePathParams;
} & FetcherExtraProps;

/**
 * The Query Table API can be used to retrieve all records in a table.
 * The API support filtering, sorting, selecting a subset of columns, and pagination.
 *
 * The overall structure of the request looks like this:
 *
 * ```json
 * // POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [...],
 *   "filter": {
 *     "$all": [...],
 *     "$any": [...]
 *     ...
 *   },
 *   "sort": {
 *     "multiple": [...]
 *     ...
 *   },
 *   "page": {
 *     ...
 *   }
 * }
 * ```
 *
 * ### Column selection
 *
 * If the `columns` array is not specified, all columns are included. For link
 * fields, only the ID column of the linked records is included in the response.
 *
 * If the `columns` array is specified, only the selected and internal
 * columns `id` and `xata` are included. The `*` wildcard can be used to
 * select all columns.
 *
 * For objects and link fields, if the column name of the object is specified, we
 * include all of its sub-keys. If only some sub-keys are specified (via dotted
 * notation, e.g. `"settings.plan"` ), then only those sub-keys from the object
 * are included.
 *
 * By the way of example, assuming two tables like this:
 *
 * ```json {"truncate": true}
 * {
 *   "formatVersion": "1.0",
 *   "tables": [
 *     {
 *       "name": "teams",
 *       "columns": [
 *         {
 *           "name": "name",
 *           "type": "string"
 *         },
 *         {
 *           "name": "owner",
 *           "type": "link",
 *           "link": {
 *             "table": "users"
 *           }
 *         },
 *         {
 *           "name": "foundedDate",
 *           "type": "datetime"
 *         },
 *       ]
 *     },
 *     {
 *       "name": "users",
 *       "columns": [
 *         {
 *           "name": "email",
 *           "type": "email"
 *         },
 *         {
 *           "name": "full_name",
 *           "type": "string"
 *         },
 *         {
 *           "name": "address",
 *           "type": "object",
 *           "columns": [
 *             {
 *               "name": "street",
 *               "type": "string"
 *             },
 *             {
 *               "name": "number",
 *               "type": "int"
 *             },
 *             {
 *               "name": "zipcode",
 *               "type": "int"
 *             }
 *           ]
 *         },
 *         {
 *           "name": "team",
 *           "type": "link",
 *           "link": {
 *             "table": "teams"
 *           }
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * A query like this:
 *
 * ```json
 * POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [
 *     "name",
 *     "address.*"
 *   ]
 * }
 * ```
 *
 * returns objects like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   }
 * }
 * ```
 *
 * while a query like this:
 *
 * ```json
 * POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [
 *     "name",
 *     "address.street"
 *   ]
 * }
 * ```
 *
 * returns objects like:
 *
 * ```json
 * {
 *   "id": "id1"
 *   "xata": {
 *     "version": 0
 *   }
 *   "name": "Kilian",
 *   "address": {
 *     "street": "New street"
 *   }
 * }
 * ```
 *
 * If you want to return all columns from the main table and selected columns from the linked table, you can do it like this:
 *
 * ```json
 * {
 *   "columns": ["*", "team.name"]
 * }
 * ```
 *
 * The `"*"` in the above means all columns, including columns of objects. This returns data like:
 *
 * ```json
 * {
 *   "id": "id1"
 *   "xata": {
 *     "version": 0
 *   }
 *   "name": "Kilian",
 *   "email": "kilian@gmail.com",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   },
 *   "team": {
 *     "id": "XX",
 *     "xata": {
 *       "version": 0
 *     },
 *     "name": "first team"
 *   }
 * }
 * ```
 *
 * If you want all columns of the linked table, you can do:
 *
 * ```json
 * {
 *   "columns": ["*", "team.*"]
 * }
 * ```
 *
 * This returns, for example:
 *
 * ```json
 * {
 *   "id": "id1"
 *   "xata": {
 *     "version": 0
 *   }
 *   "name": "Kilian",
 *   "email": "kilian@gmail.com",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   },
 *   "team": {
 *     "id": "XX",
 *     "xata": {
 *       "version": 0
 *     },
 *     "name": "first team",
 *     "code": "A1",
 *     "foundedDate": "2020-03-04T10:43:54.32Z"
 *   }
 * }
 * ```
 *
 * ### Filtering
 *
 * There are two types of operators:
 *
 * - Operators that work on a single column: `$is`, `$contains`, `$pattern`,
 *   `$includes`, `$gt`, etc.
 * - Control operators that combine multiple conditions: `$any`, `$all`, `$not` ,
 *   `$none`, etc.
 *
 * All operators start with an `$` to differentiate them from column names
 * (which are not allowed to start with a dollar sign).
 *
 * #### Exact matching and control operators
 *
 * Filter by one column:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": "value"
 *   }
 * }
 * ```
 *
 * This is equivalent to using the `$is` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$is": "value"
 *     }
 *   }
 * }
 * ```
 *
 * For example:
 *
 * ```json
 * {
 *   "filter": {
 *     "name": "r2"
 *   }
 * }
 * ```
 *
 * Or:
 *
 * ```json
 * {
 *   "filter": {
 *     "name": {
 *       "$is": "r2"
 *     }
 *   }
 * }
 * ```
 *
 * For objects, both dots and nested versions work:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.plan": "free"
 *   }
 * }
 * ```
 *
 * ```json
 * {
 *   "filter": {
 *     "settings": {
 *       "plan": "free"
 *     }
 *   }
 * }
 * ```
 *
 * If you want to OR together multiple values, you can use the `$any` operator with an array of values:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.plan": { "$any": ["free", "paid"] }
 *   }
 * }
 * ```
 *
 * If you specify multiple columns in the same filter, they are logically AND'ed together:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.dark": true,
 *     "settings.plan": "free"
 *   }
 * }
 * ```
 *
 * The above matches if both conditions are met.
 *
 * To be more explicit about it, you can use `$all` or `$any`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$any": {
 *       "settings.dark": true,
 *       "settings.plan": "free"
 *     }
 *   }
 * }
 * ```
 *
 * The `$all` and `$any` operators can also receive an array of objects, which allows for repeating column names:
 *
 * ```json
 * {
 *   "filter": {
 *     "$any": [
 *       {
 *         "name": "r1"
 *       },
 *       {
 *         "name": "r2"
 *       }
 *     ]
 *   }
 * }
 * ```
 *
 * You can check for a value being not-null with `$exists`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$exists": "settings"
 *   }
 * }
 * ```
 *
 * This can be combined with `$all` or `$any` :
 *
 * ```json
 * {
 *   "filter": {
 *     "$all": [
 *       {
 *         "$exists": "settings"
 *       },
 *       {
 *         "$exists": "name"
 *       }
 *     ]
 *   }
 * }
 * ```
 *
 * Or you can use the inverse operator `$notExists`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$notExists": "settings"
 *   }
 * }
 * ```
 *
 * #### Partial match
 *
 * `$contains` is the simplest operator for partial matching. We should generally
 * discourage overusing `$contains` because it typically can't make use of
 * indices.
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$contains": "value"
 *     }
 *   }
 * }
 * ```
 *
 * Wildcards are supported via the `$pattern` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$pattern": "v*alu?"
 *     }
 *   }
 * }
 * ```
 *
 * The `$pattern` operator accepts two wildcard characters:
 * * `*` matches zero or more characters
 * * `?` matches exactly one character
 *
 * If you want to match a string that contains a wildcard character, you can escape them using a backslash (`\`). You can escape a backslash by usign another backslash.
 *
 * We could also have `$endsWith` and `$startsWith` operators:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$endsWith": ".gz"
 *     },
 *     "<column_name>": {
 *       "$startsWith": "tmp-"
 *     }
 *   }
 * }
 * ```
 *
 * #### Numeric or datetime ranges
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$ge": 0,
 *       "$lt": 100
 *     }
 *   }
 * }
 * ```
 * Date ranges support the same operators, with the date using the format defined in
 * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339):
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$gt": "2019-10-12T07:20:50.52Z",
 *       "$lt": "2021-10-12T07:20:50.52Z"
 *     }
 *   }
 * }
 * ```
 * The supported operators are `$gt`, `$lt`, `$ge`, `$le`.
 *
 * #### Negations
 *
 * A general `$not` operator can inverse any operation.
 *
 * ```json
 * {
 *   "filter": {
 *     "$not": {
 *       "<column_name1>": "value1",
 *       "<column_name2>": "value1"
 *     }
 *   }
 * }
 * ```
 *
 * Note: in the above the two condition are AND together, so this does (NOT ( ...
 * AND ...))
 *
 * Or more complex:
 *
 * ```json
 * {
 *   "filter": {
 *     "$not": {
 *       "$any": [
 *         {
 *           "<column_name1>": "value1"
 *         },
 *         {
 *           "$all": [
 *             {
 *               "<column_name2>": "value2"
 *             },
 *             {
 *               "<column_name3>": "value3"
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   }
 * }
 * ```
 *
 * The `$not: { $any: {}}` can be shorted using the `$none` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "$none": {
 *       "<column_name1>": "value1",
 *       "<column_name2>": "value1"
 *     }
 *   }
 * }
 * ```
 *
 * In addition, you can use operators like `$isNot` or `$notExists` to simplify expressions:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$isNot": "2019-10-12T07:20:50.52Z"
 *     }
 *   }
 * }
 * ```
 *
 * #### Working with arrays
 *
 * To test that an array contains a value, use `$includes`.
 *
 * ```json
 * {
 *   "filter": {
 *     "<array_name>": {
 *       "$includes": "value"
 *     }
 *   }
 * }
 * ```
 *
 * The `$includes` operator accepts a custom predicate that will check if any
 * array values matches the predicate. For example a complex predicate can include
 * the `$all` , `$contains` and `$endsWith` operators:
 *
 * ```json
 * {
 *   "filter": {
 *     "<array name>": {
 *       "$includes": {
 *         "$all": [
 *           { "$contains": "label" },
 *           { "$not": { "$endsWith": "-debug" } }
 *         ]
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * The `$includes` all operator succeeds if any column in the array matches the
 * predicate. The `$includesAll` operator succeeds if all array items match the
 * predicate. The `$includesNone` operator succeeds if no array item matches the
 * predicate. The `$includes` operator is a synonym for the `$includesAny`
 * operator.
 *
 * Here is an example of using the `$includesAll` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.labels": {
 *       "$includesAll": [{ "$contains": "label" }]
 *     }
 *   }
 * }
 * ```
 *
 * The above matches if all label values contain the string "labels".
 *
 * ### Sorting
 *
 * Sorting by one element:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": {
 *     "index": "asc"
 *   }
 * }
 * ```
 *
 * or descendently:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": {
 *     "index": "desc"
 *   }
 * }
 * ```
 *
 * Sorting by multiple fields:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": [
 *     {
 *       "index": "desc"
 *     },
 *     {
 *       "createdAt": "desc"
 *     }
 *   ]
 * }
 * ```
 *
 * ### Pagination
 *
 * We offer cursor pagination and offset pagination. For queries that are expected to return more than 1000 records,
 * cursor pagination is needed in order to retrieve all of their results. The offset pagination method is limited to 1000 records.
 *
 * Example of size + offset pagination:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "size": 100,
 *     "offset": 200
 *   }
 * }
 * ```
 *
 * The `page.size` parameter represents the maximum number of records returned by this query. It has a default value of 20 and a maximum value of 200.
 * The `page.offset` parameter represents the number of matching records to skip. It has a default value of 0 and a maximum value of 800.
 *
 * Example of cursor pagination:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "after":"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD"
 *   }
 * }
 * ```
 *
 * In the above example, the value of the `page.after` parameter is the cursor returned by the previous query. A sample response is shown below:
 *
 * ```json
 * {
 *   "meta": {
 *     "page": {
 *       "cursor": "fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD",
 *       "more": true
 *     }
 *   },
 *   "records": [...]
 * }
 * ```
 *
 * The `page` object might contain the follow keys, in addition to `size` and `offset` that were introduced before:
 *
 * - `after`: Return the next page 'after' the current cursor
 * - `before`: Return the previous page 'before' the current cursor.
 * - `first`: Return the first page in the table from a cursor.
 * - `last`: Return the last N records in the table from a cursor, where N is the `page.size` parameter.
 *
 * The request will fail if an invalid cursor value is given to `page.before`,
 * `page.after`, `page.first` , or `page.last`. No other cursor setting can be
 * used if `page.first` or `page.last` is set in a query.
 *
 * If both `page.before` and `page.after` parameters are present we treat the
 * request as a range query. The range query will return all entries after
 * `page.after`, but before `page.before`, up to `page.size` or the maximum
 * page size. This query requires both cursors to use the same filters and sort
 * settings, plus we require `page.after < page.before`. The range query returns
 * a new cursor. If the range encompass multiple pages the next page in the range
 * can be queried by update `page.after` to the returned cursor while keeping the
 * `page.before` cursor from the first range query.
 *
 * The `filter` , `columns`, `sort` , and `page.size` configuration will be
 * encoded with the cursor. The pagination request will be invalid if
 * `filter` or `sort` is set. The columns returned and page size can be changed
 * anytime by passing the `columns` or `page.size` settings to the next query.
 *
 * **Special cursors:**
 *
 * - `page.after=end`: Result points past the last entry. The list of records
 *   returned is empty, but `page.meta.cursor` will include a cursor that can be
 *   used to "tail" the table from the end waiting for new data to be inserted.
 * - `page.before=end`: This cursor returns the last page.
 * - `page.first=<cursor>`: Go to first page. This is equivalent to querying the
 *   first page without a cursor but `filter` and `sort` . Yet the `page.first`
 *   cursor can be convenient at times as user code does not need to remember the
 *   filter, sort, columns or page size configuration. All these information are
 *   read from the cursor.
 * - `page.last=<cursor>`: Go to the end of the table. This is equivalent to querying the
 *   last page with `page.before=end`, `filter`, and `sort` . Yet the
 *   `page.last` cursor can be more convenient at times as user code does not
 *   need to remember the filter, sort, columns or page size configuration. All
 *   these information are read from the cursor.
 *
 * When using special cursors like `page.after="end"` or `page.before="end"`, we
 * still allow `filter` and `sort` to be set.
 *
 * Example of getting the last page:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "size": 10,
 *     "before": "end"
 *   }
 * }
 * ```
 */
export const queryTable = (variables: QueryTableVariables, signal?: AbortSignal) =>
  fetch<Responses.QueryResponse, QueryTableError, QueryTableRequestBody, {}, {}, QueryTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/query',
    method: 'post',
    ...variables,
    signal
  });

export type SearchBranchPathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type SearchBranchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type SearchBranchRequestBody = {
  /**
   * An array with the tables in which to search. By default, all tables are included. Optionally, filters can be included that apply to each table.
   */
  tables?: (
    | string
    | {
        /**
         * The name of the table.
         */
        table: string;
        filter?: Schemas.FilterExpression;
        target?: Schemas.TargetExpression;
        boosters?: Schemas.BoosterExpression[];
      }
  )[];
  /**
   * The query string.
   *
   * @minLength 1
   */
  query: string;
  fuzziness?: Schemas.FuzzinessExpression;
  prefix?: Schemas.PrefixExpression;
  highlight?: Schemas.HighlightExpression;
};

export type SearchBranchVariables = {
  body: SearchBranchRequestBody;
  pathParams: SearchBranchPathParams;
} & FetcherExtraProps;

/**
 * Run a free text search operation across the database branch.
 */
export const searchBranch = (variables: SearchBranchVariables, signal?: AbortSignal) =>
  fetch<Responses.SearchResponse, SearchBranchError, SearchBranchRequestBody, {}, {}, SearchBranchPathParams>({
    url: '/db/{dbBranchName}/search',
    method: 'post',
    ...variables,
    signal
  });

export type SearchTablePathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type SearchTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type SearchTableRequestBody = {
  /**
   * The query string.
   *
   * @minLength 1
   */
  query: string;
  fuzziness?: Schemas.FuzzinessExpression;
  target?: Schemas.TargetExpression;
  prefix?: Schemas.PrefixExpression;
  filter?: Schemas.FilterExpression;
  highlight?: Schemas.HighlightExpression;
  boosters?: Schemas.BoosterExpression[];
};

export type SearchTableVariables = {
  body: SearchTableRequestBody;
  pathParams: SearchTablePathParams;
} & FetcherExtraProps;

/**
 * Run a free text search operation in a particular table.
 *
 * The endpoint accepts a `query` parameter that is used for the free text search and a set of structured filters (via the `filter` parameter) that are applied before the search. The `filter` parameter uses the same syntax as the [query endpoint](/api-reference/db/db_branch_name/tables/table_name/) with the following exceptions:
 * * filters `$contains`, `$startsWith`, `$endsWith` don't work on columns of type `text`
 * * filtering on columns of type `multiple` is currently unsupported
 */
export const searchTable = (variables: SearchTableVariables, signal?: AbortSignal) =>
  fetch<Responses.SearchResponse, SearchTableError, SearchTableRequestBody, {}, {}, SearchTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/search',
    method: 'post',
    ...variables,
    signal
  });

export type SummarizeTablePathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type SummarizeTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type SummarizeTableRequestBody = {
  filter?: Schemas.FilterExpression;
  columns?: Schemas.ColumnsProjection;
  summaries?: Schemas.SummaryExpressionList;
  sort?: Schemas.SortExpression;
  summariesFilter?: Schemas.FilterExpression;
};

export type SummarizeTableVariables = {
  body?: SummarizeTableRequestBody;
  pathParams: SummarizeTablePathParams;
} & FetcherExtraProps;

/**
 * This endpoint allows you to (optionally) define groups, and then to run
 * calculations on the values in each group. This is most helpful when
 * you'd like to understand the data you have in your database.
 *
 * A group is a combination of unique values. If you create a group for
 * `sold_by`, `product_name`, we will return one row for every combination
 * of `sold_by` and `product_name` you have in your database. When you
 * want to calculate statistics, you define these groups and ask Xata to
 * calculate data on each group.
 *
 * **Some questions you can ask of your data:**
 *
 * How many records do I have in this table?
 * - Set `columns: []` as we we want data from the entire table, so we ask
 * for no groups.
 * - Set `summaries: {"total": {"count": "*"}}` in order to see the count
 * of all records. We use `count: *` here we'd like to know the total
 * amount of rows; ignoring whether they are `null` or not.
 *
 * What are the top total sales for each product in July 2022 and sold
 * more than 10 units?
 * - Set `filter: {soldAt: {
 *   "$ge": "2022-07-01T00:00:00.000Z",
 *   "$lt": "2022-08-01T00:00:00.000Z"}
 * }`
 * in order to limit the result set to sales recorded in July 2022.
 * - Set `columns: [product_name]` as we'd like to run calculations on
 * each unique product name in our table. Setting `columns` like this will
 * produce one row per unique product name.
 * - Set `summaries: {"total_sales": {"count": "product_name"}}` as we'd
 * like to create a field called "total_sales" for each group. This field
 * will count all rows in each group with non-null product names.
 * - Set `sort: [{"total_sales": "desc"}]` in order to bring the rows with
 * the highest total_sales field to the top.
 * - Set `summariesFilter: {"total_sales": {"$ge": 10}}` to only send back data
 * with greater than or equal to 10 units.
 *
 * `columns`: tells Xata how to create each group. If you add `product_id`
 * we will create a new group for every unique `product_id`.
 *
 * `summaries`: tells Xata which calculations to run on each group.
 *
 * `sort`: tells Xata in which order you'd like to see results. You may
 * sort by fields specified in `columns` as well as the summary names
 * defined in `summaries`.
 *
 * note: Sorting on summarized values can be slower on very large tables;
 * this will impact your rate limit significantly more than other queries.
 * Try use `filter` [coming soon] to reduce the amount of data being
 * processed in order to reduce impact on your limits.
 *
 * `summariesFilter`: tells Xata how to filter the results of a summary.
 * It has the same syntax as `filter`, however, by using `summariesFilter`
 * you may also filter on the results of a query.
 *
 * note: This is a much slower to use than `filter`. We recommend using
 * `filter` wherever possible and `summariesFilter` when it's not
 * possible to use `filter`.
 */
export const summarizeTable = (variables: SummarizeTableVariables, signal?: AbortSignal) =>
  fetch<Responses.SummarizeResponse, SummarizeTableError, SummarizeTableRequestBody, {}, {}, SummarizeTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/summarize',
    method: 'post',
    ...variables,
    signal
  });

export type AggregateTablePathParams = {
  /**
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /**
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type AggregateTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type AggregateTableRequestBody = {
  filter?: Schemas.FilterExpression;
  aggs?: Schemas.AggExpressionMap;
};

export type AggregateTableVariables = {
  body?: AggregateTableRequestBody;
  pathParams: AggregateTablePathParams;
} & FetcherExtraProps;

/**
 * This endpoint allows you to run aggragations (analytics) on the data from one table.
 * While the summary endpoint is served from a transactional store and the results are strongly
 * consistent, the aggregate endpoint is served from our columnar store and the results are
 * only eventually consistent. On the other hand, the aggregate endpoint uses a
 * store that is more appropiate for analytics, makes use of approximative algorithms
 * (e.g for cardinality), and is generally faster and can do more complex aggregations.
 */
export const aggregateTable = (variables: AggregateTableVariables, signal?: AbortSignal) =>
  fetch<Responses.AggResponse, AggregateTableError, AggregateTableRequestBody, {}, {}, AggregateTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/aggregate',
    method: 'post',
    ...variables,
    signal
  });

export type CPGetDatabaseListPathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
};

export type CPGetDatabaseListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type CPGetDatabaseListVariables = {
  pathParams: CPGetDatabaseListPathParams;
} & FetcherExtraProps;

/**
 * List all databases available in your Workspace.
 */
export const cPGetDatabaseList = (variables: CPGetDatabaseListVariables, signal?: AbortSignal) =>
  fetch<Schemas.CPListDatabasesResponse, CPGetDatabaseListError, undefined, {}, {}, CPGetDatabaseListPathParams>({
    url: '/workspaces/{workspaceId}/dbs',
    method: 'get',
    ...variables,
    signal
  });

export type CPCreateDatabasePathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
};

export type CPCreateDatabaseError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type CPCreateDatabaseResponse = {
  /**
   * @minLength 1
   */
  databaseName?: string;
  branchName?: string;
};

export type CPCreateDatabaseRequestBody = {
  /**
   * @minLength 1
   */
  branchName?: string;
  /**
   * @minLength 1
   */
  region: string;
  ui?: {
    color?: string;
  };
  metadata?: Schemas.BranchMetadata;
};

export type CPCreateDatabaseVariables = {
  body: CPCreateDatabaseRequestBody;
  pathParams: CPCreateDatabasePathParams;
} & FetcherExtraProps;

/**
 * Create Database with identifier name
 */
export const cPCreateDatabase = (variables: CPCreateDatabaseVariables, signal?: AbortSignal) =>
  fetch<
    CPCreateDatabaseResponse,
    CPCreateDatabaseError,
    CPCreateDatabaseRequestBody,
    {},
    {},
    CPCreateDatabasePathParams
  >({ url: '/workspaces/{workspaceId}/dbs/{dbName}', method: 'put', ...variables, signal });

export type CPDeleteDatabasePathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
};

export type CPDeleteDatabaseError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CPDeleteDatabaseVariables = {
  pathParams: CPDeleteDatabasePathParams;
} & FetcherExtraProps;

/**
 * Delete a database and all of its branches and tables permanently.
 */
export const cPDeleteDatabase = (variables: CPDeleteDatabaseVariables, signal?: AbortSignal) =>
  fetch<undefined, CPDeleteDatabaseError, undefined, {}, {}, CPDeleteDatabasePathParams>({
    url: '/workspaces/{workspaceId}/dbs/{dbName}',
    method: 'delete',
    ...variables,
    signal
  });

export type CPGetCPDatabaseMetadataPathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
};

export type CPGetCPDatabaseMetadataError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CPGetCPDatabaseMetadataVariables = {
  pathParams: CPGetCPDatabaseMetadataPathParams;
} & FetcherExtraProps;

/**
 * Retrieve metadata of the given database
 */
export const cPGetCPDatabaseMetadata = (variables: CPGetCPDatabaseMetadataVariables, signal?: AbortSignal) =>
  fetch<Schemas.CPDatabaseMetadata, CPGetCPDatabaseMetadataError, undefined, {}, {}, CPGetCPDatabaseMetadataPathParams>(
    { url: '/workspaces/{workspaceId}/dbs/{dbName}/metadata', method: 'get', ...variables, signal }
  );

export type CPUpdateCPDatabaseMetadataPathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
  /**
   * The Database Name
   */
  dbName: Schemas.DBName;
};

export type CPUpdateCPDatabaseMetadataError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CPUpdateCPDatabaseMetadataRequestBody = {
  ui?: {
    /**
     * @minLength 1
     */
    color?: string;
  };
};

export type CPUpdateCPDatabaseMetadataVariables = {
  body?: CPUpdateCPDatabaseMetadataRequestBody;
  pathParams: CPUpdateCPDatabaseMetadataPathParams;
} & FetcherExtraProps;

/**
 * Update the color of the selected database
 */
export const cPUpdateCPDatabaseMetadata = (variables: CPUpdateCPDatabaseMetadataVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CPDatabaseMetadata,
    CPUpdateCPDatabaseMetadataError,
    CPUpdateCPDatabaseMetadataRequestBody,
    {},
    {},
    CPUpdateCPDatabaseMetadataPathParams
  >({ url: '/workspaces/{workspaceId}/dbs/{dbName}/metadata', method: 'patch', ...variables, signal });

export type ListRegionsPathParams = {
  /**
   * Workspace ID
   */
  workspaceId: Schemas.WorkspaceID;
};

export type ListRegionsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type ListRegionsVariables = {
  pathParams: ListRegionsPathParams;
} & FetcherExtraProps;

/**
 * List regions available to create a database on
 */
export const listRegions = (variables: ListRegionsVariables, signal?: AbortSignal) =>
  fetch<Schemas.ListRegionsResponse, ListRegionsError, undefined, {}, {}, ListRegionsPathParams>({
    url: '/workspaces/{workspaceId}/regions',
    method: 'get',
    ...variables,
    signal
  });

export const operationsByTag = {
  users: { getUser, updateUser, deleteUser },
  authentication: { getUserAPIKeys, createUserAPIKey, deleteUserAPIKey },
  workspaces: {
    getWorkspacesList,
    createWorkspace,
    getWorkspace,
    updateWorkspace,
    deleteWorkspace,
    getWorkspaceMembersList,
    updateWorkspaceMemberRole,
    removeWorkspaceMember
  },
  invites: {
    inviteWorkspaceMember,
    updateWorkspaceMemberInvite,
    cancelWorkspaceMemberInvite,
    acceptWorkspaceMemberInvite,
    resendWorkspaceMemberInvite
  },
  database: { getDatabaseList, createDatabase, deleteDatabase, getDatabaseMetadata, updateDatabaseMetadata },
  branch: {
    getBranchList,
    getBranchDetails,
    createBranch,
    deleteBranch,
    updateBranchMetadata,
    getBranchMetadata,
    getBranchStats,
    getGitBranchesMapping,
    addGitBranchesEntry,
    removeGitBranchesEntry,
    resolveBranch
  },
  migrations: {
    getBranchMigrationHistory,
    getBranchMigrationPlan,
    executeBranchMigrationPlan,
    getBranchSchemaHistory,
    compareBranchWithUserSchema,
    compareBranchSchemas,
    updateBranchSchema,
    previewBranchSchemaEdit,
    applyBranchSchemaEdit
  },
  migrationRequests: {
    queryMigrationRequests,
    createMigrationRequest,
    getMigrationRequest,
    updateMigrationRequest,
    listMigrationRequestsCommits,
    compareMigrationRequest,
    getMigrationRequestIsMerged,
    mergeMigrationRequest
  },
  table: {
    createTable,
    deleteTable,
    updateTable,
    getTableSchema,
    setTableSchema,
    getTableColumns,
    addTableColumn,
    getColumn,
    updateColumn,
    deleteColumn
  },
  records: {
    insertRecord,
    getRecord,
    insertRecordWithID,
    updateRecordWithID,
    upsertRecordWithID,
    deleteRecord,
    bulkInsertTableRecords
  },
  searchAndFilter: { queryTable, searchBranch, searchTable, summarizeTable, aggregateTable },
  databases: {
    cPGetDatabaseList,
    cPCreateDatabase,
    cPDeleteDatabase,
    cPGetCPDatabaseMetadata,
    cPUpdateCPDatabaseMetadata,
    listRegions
  }
};
