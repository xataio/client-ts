/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import type * as Fetcher from './fetcher';
import { fetch, FetcherExtraProps } from './fetcher';
import type * as Schemas from './schemas';
import type * as Responses from './responses';

export type GetUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetUserVariables = FetcherExtraProps;

/**
 * Return details of the user making the request
 */
export const getUser = (variables: GetUserVariables) =>
  fetch<Schemas.UserWithID, GetUserError, undefined, {}, {}, {}>({ url: '/user', method: 'get', ...variables });

export type UpdateUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateUserVariables = {
  body: Schemas.User;
} & FetcherExtraProps;

/**
 * Update user info
 */
export const updateUser = (variables: UpdateUserVariables) =>
  fetch<Schemas.UserWithID, UpdateUserError, Schemas.User, {}, {}, {}>({ url: '/user', method: 'put', ...variables });

export type DeleteUserError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteUserVariables = FetcherExtraProps;

/**
 * Delete the user making the request
 */
export const deleteUser = (variables: DeleteUserVariables) =>
  fetch<undefined, DeleteUserError, undefined, {}, {}, {}>({ url: '/user', method: 'delete', ...variables });

export type GetUserAPIKeysError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetUserAPIKeysResponse = {
  keys: {
    name: string;
    createdAt: Schemas.DateTime;
  }[];
};

export type GetUserAPIKeysVariables = FetcherExtraProps;

/**
 * Retrieve a list of existing user API keys
 */
export const getUserAPIKeys = (variables: GetUserAPIKeysVariables) =>
  fetch<GetUserAPIKeysResponse, GetUserAPIKeysError, undefined, {}, {}, {}>({
    url: '/user/keys',
    method: 'get',
    ...variables
  });

export type CreateUserAPIKeyPathParams = {
  /*
   * API Key name
   */
  keyName: Schemas.APIKeyName;
};

export type CreateUserAPIKeyError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CreateUserAPIKeyResponse = {
  name: string;
  key: string;
  createdAt: Schemas.DateTime;
};

export type CreateUserAPIKeyVariables = {
  pathParams: CreateUserAPIKeyPathParams;
} & FetcherExtraProps;

/**
 * Create and return new API key
 */
export const createUserAPIKey = (variables: CreateUserAPIKeyVariables) =>
  fetch<CreateUserAPIKeyResponse, CreateUserAPIKeyError, undefined, {}, {}, CreateUserAPIKeyPathParams>({
    url: '/user/keys/{keyName}',
    method: 'post',
    ...variables
  });

export type DeleteUserAPIKeyPathParams = {
  /*
   * API Key name
   */
  keyName: Schemas.APIKeyName;
};

export type DeleteUserAPIKeyError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteUserAPIKeyVariables = {
  pathParams: DeleteUserAPIKeyPathParams;
} & FetcherExtraProps;

/**
 * Delete an existing API key
 */
export const deleteUserAPIKey = (variables: DeleteUserAPIKeyVariables) =>
  fetch<undefined, DeleteUserAPIKeyError, undefined, {}, {}, DeleteUserAPIKeyPathParams>({
    url: '/user/keys/{keyName}',
    method: 'delete',
    ...variables
  });

export type CreateWorkspaceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CreateWorkspaceVariables = {
  body: Schemas.WorkspaceMeta;
} & FetcherExtraProps;

/**
 * Creates a new workspace with the user requesting it as its single owner.
 */
export const createWorkspace = (variables: CreateWorkspaceVariables) =>
  fetch<Schemas.Workspace, CreateWorkspaceError, Schemas.WorkspaceMeta, {}, {}, {}>({
    url: '/workspaces',
    method: 'post',
    ...variables
  });

export type GetWorkspacesListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetWorkspacesListResponse = {
  workspaces: {
    id: Schemas.WorkspaceID;
    name: string;
    slug: string;
    role: Schemas.Role;
  }[];
};

export type GetWorkspacesListVariables = FetcherExtraProps;

/**
 * Retrieve the list of workspaces the user belongs to
 */
export const getWorkspacesList = (variables: GetWorkspacesListVariables) =>
  fetch<GetWorkspacesListResponse, GetWorkspacesListError, undefined, {}, {}, {}>({
    url: '/workspaces',
    method: 'get',
    ...variables
  });

export type GetWorkspacePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
};

export type GetWorkspaceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetWorkspaceVariables = {
  pathParams: GetWorkspacePathParams;
} & FetcherExtraProps;

/**
 * Retrieve workspace info from a workspace ID
 */
export const getWorkspace = (variables: GetWorkspaceVariables) =>
  fetch<Schemas.Workspace, GetWorkspaceError, undefined, {}, {}, GetWorkspacePathParams>({
    url: '/workspaces/{workspaceId}',
    method: 'get',
    ...variables
  });

export type UpdateWorkspacePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
};

export type UpdateWorkspaceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateWorkspaceVariables = {
  body: Schemas.WorkspaceMeta;
  pathParams: UpdateWorkspacePathParams;
} & FetcherExtraProps;

/**
 * Update workspace info
 */
export const updateWorkspace = (variables: UpdateWorkspaceVariables) =>
  fetch<Schemas.Workspace, UpdateWorkspaceError, Schemas.WorkspaceMeta, {}, {}, UpdateWorkspacePathParams>({
    url: '/workspaces/{workspaceId}',
    method: 'put',
    ...variables
  });

export type DeleteWorkspacePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
};

export type DeleteWorkspaceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteWorkspaceVariables = {
  pathParams: DeleteWorkspacePathParams;
} & FetcherExtraProps;

/**
 * Delete the workspace with the provided ID
 */
export const deleteWorkspace = (variables: DeleteWorkspaceVariables) =>
  fetch<undefined, DeleteWorkspaceError, undefined, {}, {}, DeleteWorkspacePathParams>({
    url: '/workspaces/{workspaceId}',
    method: 'delete',
    ...variables
  });

export type GetWorkspaceMembersListPathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
};

export type GetWorkspaceMembersListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetWorkspaceMembersListVariables = {
  pathParams: GetWorkspaceMembersListPathParams;
} & FetcherExtraProps;

/**
 * Retrieve the list of members of the given workspace
 */
export const getWorkspaceMembersList = (variables: GetWorkspaceMembersListVariables) =>
  fetch<Schemas.WorkspaceMembers, GetWorkspaceMembersListError, undefined, {}, {}, GetWorkspaceMembersListPathParams>({
    url: '/workspaces/{workspaceId}/members',
    method: 'get',
    ...variables
  });

export type UpdateWorkspaceMemberRolePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
  /*
   * UserID
   */
  userId: Schemas.UserID;
};

export type UpdateWorkspaceMemberRoleError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateWorkspaceMemberRoleRequestBody = {
  role: Schemas.Role;
};

export type UpdateWorkspaceMemberRoleVariables = {
  body: UpdateWorkspaceMemberRoleRequestBody;
  pathParams: UpdateWorkspaceMemberRolePathParams;
} & FetcherExtraProps;

/**
 * Update a workspace member role. Workspaces must always have at least one owner, so this operation will fail if trying to remove owner role from the last owner in the workspace.
 */
export const updateWorkspaceMemberRole = (variables: UpdateWorkspaceMemberRoleVariables) =>
  fetch<
    undefined,
    UpdateWorkspaceMemberRoleError,
    UpdateWorkspaceMemberRoleRequestBody,
    {},
    {},
    UpdateWorkspaceMemberRolePathParams
  >({ url: '/workspaces/{workspaceId}/members/{userId}', method: 'put', ...variables });

export type RemoveWorkspaceMemberPathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
  /*
   * UserID
   */
  userId: Schemas.UserID;
};

export type RemoveWorkspaceMemberError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type RemoveWorkspaceMemberVariables = {
  pathParams: RemoveWorkspaceMemberPathParams;
} & FetcherExtraProps;

/**
 * Remove the member from the workspace
 */
export const removeWorkspaceMember = (variables: RemoveWorkspaceMemberVariables) =>
  fetch<undefined, RemoveWorkspaceMemberError, undefined, {}, {}, RemoveWorkspaceMemberPathParams>({
    url: '/workspaces/{workspaceId}/members/{userId}',
    method: 'delete',
    ...variables
  });

export type InviteWorkspaceMemberPathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
};

export type InviteWorkspaceMemberError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 409;
      payload: Responses.SimpleError;
    }
>;

export type InviteWorkspaceMemberRequestBody = {
  /*
   * @format email
   */
  email: string;
  role: Schemas.Role;
};

export type InviteWorkspaceMemberVariables = {
  body: InviteWorkspaceMemberRequestBody;
  pathParams: InviteWorkspaceMemberPathParams;
} & FetcherExtraProps;

/**
 * Invite some user to join the workspace with the given role
 */
export const inviteWorkspaceMember = (variables: InviteWorkspaceMemberVariables) =>
  fetch<
    Schemas.WorkspaceInvite,
    InviteWorkspaceMemberError,
    InviteWorkspaceMemberRequestBody,
    {},
    {},
    InviteWorkspaceMemberPathParams
  >({ url: '/workspaces/{workspaceId}/invites', method: 'post', ...variables });

export type UpdateWorkspaceMemberInvitePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
  /*
   * Invite identifier
   */
  inviteId: Schemas.InviteID;
};

export type UpdateWorkspaceMemberInviteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type UpdateWorkspaceMemberInviteRequestBody = {
  role: Schemas.Role;
};

export type UpdateWorkspaceMemberInviteVariables = {
  body: UpdateWorkspaceMemberInviteRequestBody;
  pathParams: UpdateWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;

/**
 * This operation provides a way to update an existing invite. Updates are performed in-place; they do not change the invite link, the expiry time, nor do they re-notify the recipient of the invite.
 */
export const updateWorkspaceMemberInvite = (variables: UpdateWorkspaceMemberInviteVariables) =>
  fetch<
    Schemas.WorkspaceInvite,
    UpdateWorkspaceMemberInviteError,
    UpdateWorkspaceMemberInviteRequestBody,
    {},
    {},
    UpdateWorkspaceMemberInvitePathParams
  >({ url: '/workspaces/{workspaceId}/invites/{inviteId}', method: 'patch', ...variables });

export type CancelWorkspaceMemberInvitePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
  /*
   * Invite identifier
   */
  inviteId: Schemas.InviteID;
};

export type CancelWorkspaceMemberInviteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CancelWorkspaceMemberInviteVariables = {
  pathParams: CancelWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;

/**
 * This operation provides a way to cancel invites by deleting them. Already accepted invites cannot be deleted.
 */
export const cancelWorkspaceMemberInvite = (variables: CancelWorkspaceMemberInviteVariables) =>
  fetch<undefined, CancelWorkspaceMemberInviteError, undefined, {}, {}, CancelWorkspaceMemberInvitePathParams>({
    url: '/workspaces/{workspaceId}/invites/{inviteId}',
    method: 'delete',
    ...variables
  });

export type ResendWorkspaceMemberInvitePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
  /*
   * Invite identifier
   */
  inviteId: Schemas.InviteID;
};

export type ResendWorkspaceMemberInviteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type ResendWorkspaceMemberInviteVariables = {
  pathParams: ResendWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;

/**
 * This operation provides a way to resend an Invite notification. Invite notifications can only be sent for Invites not yet accepted.
 */
export const resendWorkspaceMemberInvite = (variables: ResendWorkspaceMemberInviteVariables) =>
  fetch<undefined, ResendWorkspaceMemberInviteError, undefined, {}, {}, ResendWorkspaceMemberInvitePathParams>({
    url: '/workspaces/{workspaceId}/invites/{inviteId}/resend',
    method: 'post',
    ...variables
  });

export type AcceptWorkspaceMemberInvitePathParams = {
  /*
   * Workspace name
   */
  workspaceId: Schemas.WorkspaceID;
  /*
   * Invite Key (secret) for the invited user
   */
  inviteKey: Schemas.InviteKey;
};

export type AcceptWorkspaceMemberInviteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type AcceptWorkspaceMemberInviteVariables = {
  pathParams: AcceptWorkspaceMemberInvitePathParams;
} & FetcherExtraProps;

/**
 * Accept the invitation to join a workspace. If the operation succeeds the user will be a member of the workspace
 */
export const acceptWorkspaceMemberInvite = (variables: AcceptWorkspaceMemberInviteVariables) =>
  fetch<undefined, AcceptWorkspaceMemberInviteError, undefined, {}, {}, AcceptWorkspaceMemberInvitePathParams>({
    url: '/workspaces/{workspaceId}/invites/{inviteKey}/accept',
    method: 'post',
    ...variables
  });

export type GetDatabaseListPathParams = {
  workspace: string;
};

export type GetDatabaseListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type GetDatabaseListVariables = {
  pathParams: GetDatabaseListPathParams;
} & FetcherExtraProps;

/**
 * List all databases available in your Workspace.
 */
export const getDatabaseList = (variables: GetDatabaseListVariables) =>
  fetch<Schemas.ListDatabasesResponse, GetDatabaseListError, undefined, {}, {}, GetDatabaseListPathParams>({
    url: '/dbs',
    method: 'get',
    ...variables
  });

export type GetBranchListPathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type GetBranchListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchListVariables = {
  pathParams: GetBranchListPathParams;
} & FetcherExtraProps;

/**
 * List all available Branches
 */
export const getBranchList = (variables: GetBranchListVariables) =>
  fetch<Schemas.ListBranchesResponse, GetBranchListError, undefined, {}, {}, GetBranchListPathParams>({
    url: '/dbs/{dbName}',
    method: 'get',
    ...variables
  });

export type CreateDatabasePathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type CreateDatabaseError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type CreateDatabaseResponse = {
  /*
   * @minLength 1
   */
  databaseName: string;
  branchName?: string;
};

export type CreateDatabaseRequestBody = {
  /*
   * @minLength 1
   */
  displayName?: string;
  /*
   * @minLength 1
   */
  branchName?: string;
  ui?: {
    color?: string;
  };
  metadata?: Schemas.BranchMetadata;
};

export type CreateDatabaseVariables = {
  body?: CreateDatabaseRequestBody;
  pathParams: CreateDatabasePathParams;
} & FetcherExtraProps;

/**
 * Create Database with identifier name
 */
export const createDatabase = (variables: CreateDatabaseVariables) =>
  fetch<CreateDatabaseResponse, CreateDatabaseError, CreateDatabaseRequestBody, {}, {}, CreateDatabasePathParams>({
    url: '/dbs/{dbName}',
    method: 'put',
    ...variables
  });

export type DeleteDatabasePathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type DeleteDatabaseError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteDatabaseVariables = {
  pathParams: DeleteDatabasePathParams;
} & FetcherExtraProps;

/**
 * Delete a database and all of its branches and tables permanently.
 */
export const deleteDatabase = (variables: DeleteDatabaseVariables) =>
  fetch<undefined, DeleteDatabaseError, undefined, {}, {}, DeleteDatabasePathParams>({
    url: '/dbs/{dbName}',
    method: 'delete',
    ...variables
  });

export type GetDatabaseMetadataPathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type GetDatabaseMetadataError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetDatabaseMetadataVariables = {
  pathParams: GetDatabaseMetadataPathParams;
} & FetcherExtraProps;

/**
 * Retrieve metadata of the given database
 */
export const getDatabaseMetadata = (variables: GetDatabaseMetadataVariables) =>
  fetch<Schemas.DatabaseMetadata, GetDatabaseMetadataError, undefined, {}, {}, GetDatabaseMetadataPathParams>({
    url: '/dbs/{dbName}/metadata',
    method: 'get',
    ...variables
  });

export type GetGitBranchesMappingPathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type GetGitBranchesMappingError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type GetGitBranchesMappingVariables = {
  pathParams: GetGitBranchesMappingPathParams;
} & FetcherExtraProps;

/**
 * Lists all the git branches in the mapping, and their associated Xata branches.
 *
 * Example response:
 *
 * ```json
 * {
 *   "mappings": [
 *       {
 *         "gitBranch": "main",
 *         "xataBranch": "main"
 *       },
 *       {
 *         "gitBranch": "gitBranch1",
 *         "xataBranch": "xataBranch1"
 *       }
 *       {
 *         "gitBranch": "xataBranch2",
 *         "xataBranch": "xataBranch2"
 *       }
 *   ]
 * }
 * ```
 */
export const getGitBranchesMapping = (variables: GetGitBranchesMappingVariables) =>
  fetch<
    Schemas.ListGitBranchesResponse,
    GetGitBranchesMappingError,
    undefined,
    {},
    {},
    GetGitBranchesMappingPathParams
  >({ url: '/dbs/{dbName}/gitBranches', method: 'get', ...variables });

export type AddGitBranchesEntryPathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type AddGitBranchesEntryError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type AddGitBranchesEntryResponse = {
  /*
   * Warning message
   */
  warning?: string;
};

export type AddGitBranchesEntryRequestBody = {
  /*
   * The name of the Git branch.
   */
  gitBranch: string;
  /*
   * The name of the Xata branch.
   */
  xataBranch: Schemas.BranchName;
};

export type AddGitBranchesEntryVariables = {
  body: AddGitBranchesEntryRequestBody;
  pathParams: AddGitBranchesEntryPathParams;
} & FetcherExtraProps;

/**
 * Adds an entry to the mapping of git branches to Xata branches. The git branch and the Xata branch must be present in the body of the request. If the Xata branch doesn't exist, a 400 error is returned.
 *
 * If the git branch is already present in the mapping, the old entry is overwritten, and a warning message is included in the response. If the git branch is added and didn't exist before, the response code is 204. If the git branch existed and it was overwritten, the response code is 201.
 *
 * Example request:
 *
 * ```json
 * // POST https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches
 * {
 *   "gitBranch": "fix/bug123",
 *   "xataBranch": "fix_bug"
 * }
 * ```
 */
export const addGitBranchesEntry = (variables: AddGitBranchesEntryVariables) =>
  fetch<
    AddGitBranchesEntryResponse,
    AddGitBranchesEntryError,
    AddGitBranchesEntryRequestBody,
    {},
    {},
    AddGitBranchesEntryPathParams
  >({ url: '/dbs/{dbName}/gitBranches', method: 'post', ...variables });

export type RemoveGitBranchesEntryPathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type RemoveGitBranchesEntryQueryParams = {
  /*
   * The Git Branch to remove from the mapping
   */
  gitBranch: string;
};

export type RemoveGitBranchesEntryError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type RemoveGitBranchesEntryVariables = {
  pathParams: RemoveGitBranchesEntryPathParams;
  queryParams: RemoveGitBranchesEntryQueryParams;
} & FetcherExtraProps;

/**
 * Removes an entry from the mapping of git branches to Xata branches. The name of the git branch must be passed as a query parameter. If the git branch is not found, the endpoint returns a 404 status code.
 *
 * Example request:
 *
 * ```json
 * // DELETE https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches?gitBranch=fix%2Fbug123
 * ```
 */
export const removeGitBranchesEntry = (variables: RemoveGitBranchesEntryVariables) =>
  fetch<
    undefined,
    RemoveGitBranchesEntryError,
    undefined,
    {},
    RemoveGitBranchesEntryQueryParams,
    RemoveGitBranchesEntryPathParams
  >({ url: '/dbs/{dbName}/gitBranches', method: 'delete', ...variables });

export type ResolveBranchPathParams = {
  /*
   * The Database Name
   */
  dbName: Schemas.DBName;
  workspace: string;
};

export type ResolveBranchQueryParams = {
  /*
   * The Git Branch
   */
  gitBranch?: string;
  /*
   * Default branch to fallback to
   */
  fallbackBranch?: string;
};

export type ResolveBranchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type ResolveBranchResponse = {
  branch: string;
  reason: {
    code: 'FOUND_IN_MAPPING' | 'BRANCH_EXISTS' | 'FALLBACK_BRANCH' | 'DEFAULT_BRANCH';
    message: string;
  };
};

export type ResolveBranchVariables = {
  pathParams: ResolveBranchPathParams;
  queryParams?: ResolveBranchQueryParams;
} & FetcherExtraProps;

/**
 * In order to resolve the database branch, the following algorithm is used:
 * * if the `gitBranch` was provided and is found in the [git branches mapping](/api-reference/dbs/db_name/gitBranches), the associated Xata branch is returned
 * * else, if a Xata branch with the exact same name as `gitBranch` exists, return it
 * * else, if `fallbackBranch` is provided and a branch with that name exists, return it
 * * else, return the default branch of the DB (`main` or the first branch)
 *
 * Example call:
 *
 * ```json
 * // GET https://tutorial-ng7s8c.xata.sh/dbs/demo/dbs/demo/resolveBranch?gitBranch=test&fallbackBranch=tsg
 * ```
 *
 * Example response:
 *
 * ```json
 * {
 *   "branch": "main",
 *   "reason": {
 *     "code": "DEFAULT_BRANCH",
 *     "message": "Default branch for this database (main)"
 *   }
 * }
 * ```
 */
export const resolveBranch = (variables: ResolveBranchVariables) =>
  fetch<ResolveBranchResponse, ResolveBranchError, undefined, {}, ResolveBranchQueryParams, ResolveBranchPathParams>({
    url: '/dbs/{dbName}/resolveBranch',
    method: 'get',
    ...variables
  });

export type GetBranchDetailsPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchDetailsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchDetailsVariables = {
  pathParams: GetBranchDetailsPathParams;
} & FetcherExtraProps;

export const getBranchDetails = (variables: GetBranchDetailsVariables) =>
  fetch<Schemas.DBBranch, GetBranchDetailsError, undefined, {}, {}, GetBranchDetailsPathParams>({
    url: '/db/{dbBranchName}',
    method: 'get',
    ...variables
  });

export type CreateBranchPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type CreateBranchQueryParams = {
  /*
   * Name of source branch to branch the new schema from
   */
  from?: string;
};

export type CreateBranchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type CreateBranchResponse = {
  /*
   * @minLength 1
   */
  databaseName: string;
  branchName: string;
};

export type CreateBranchRequestBody = {
  /*
   * Select the branch to fork from. Defaults to 'main'
   */
  from?: string;
  metadata?: Schemas.BranchMetadata;
};

export type CreateBranchVariables = {
  body?: CreateBranchRequestBody;
  pathParams: CreateBranchPathParams;
  queryParams?: CreateBranchQueryParams;
} & FetcherExtraProps;

export const createBranch = (variables: CreateBranchVariables) =>
  fetch<
    CreateBranchResponse,
    CreateBranchError,
    CreateBranchRequestBody,
    {},
    CreateBranchQueryParams,
    CreateBranchPathParams
  >({ url: '/db/{dbBranchName}', method: 'put', ...variables });

export type DeleteBranchPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type DeleteBranchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteBranchVariables = {
  pathParams: DeleteBranchPathParams;
} & FetcherExtraProps;

/**
 * Delete the branch in the database and all its resources
 */
export const deleteBranch = (variables: DeleteBranchVariables) =>
  fetch<undefined, DeleteBranchError, undefined, {}, {}, DeleteBranchPathParams>({
    url: '/db/{dbBranchName}',
    method: 'delete',
    ...variables
  });

export type UpdateBranchMetadataPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type UpdateBranchMetadataError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateBranchMetadataVariables = {
  body?: Schemas.BranchMetadata;
  pathParams: UpdateBranchMetadataPathParams;
} & FetcherExtraProps;

/**
 * Update the branch metadata
 */
export const updateBranchMetadata = (variables: UpdateBranchMetadataVariables) =>
  fetch<undefined, UpdateBranchMetadataError, Schemas.BranchMetadata, {}, {}, UpdateBranchMetadataPathParams>({
    url: '/db/{dbBranchName}/metadata',
    method: 'put',
    ...variables
  });

export type GetBranchMetadataPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchMetadataError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchMetadataVariables = {
  pathParams: GetBranchMetadataPathParams;
} & FetcherExtraProps;

export const getBranchMetadata = (variables: GetBranchMetadataVariables) =>
  fetch<Schemas.BranchMetadata, GetBranchMetadataError, undefined, {}, {}, GetBranchMetadataPathParams>({
    url: '/db/{dbBranchName}/metadata',
    method: 'get',
    ...variables
  });

export type GetBranchMigrationHistoryPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchMigrationHistoryError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchMigrationHistoryResponse = {
  startedFrom?: Schemas.StartedFromMetadata;
  migrations?: Schemas.BranchMigration[];
};

export type GetBranchMigrationHistoryRequestBody = {
  limit?: number;
  startFrom?: string;
};

export type GetBranchMigrationHistoryVariables = {
  body?: GetBranchMigrationHistoryRequestBody;
  pathParams: GetBranchMigrationHistoryPathParams;
} & FetcherExtraProps;

export const getBranchMigrationHistory = (variables: GetBranchMigrationHistoryVariables) =>
  fetch<
    GetBranchMigrationHistoryResponse,
    GetBranchMigrationHistoryError,
    GetBranchMigrationHistoryRequestBody,
    {},
    {},
    GetBranchMigrationHistoryPathParams
  >({ url: '/db/{dbBranchName}/migrations', method: 'get', ...variables });

export type ExecuteBranchMigrationPlanPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type ExecuteBranchMigrationPlanError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type ExecuteBranchMigrationPlanRequestBody = {
  version: number;
  migration: Schemas.BranchMigration;
};

export type ExecuteBranchMigrationPlanVariables = {
  body: ExecuteBranchMigrationPlanRequestBody;
  pathParams: ExecuteBranchMigrationPlanPathParams;
} & FetcherExtraProps;

/**
 * Apply a migration plan to the branch
 */
export const executeBranchMigrationPlan = (variables: ExecuteBranchMigrationPlanVariables) =>
  fetch<
    undefined,
    ExecuteBranchMigrationPlanError,
    ExecuteBranchMigrationPlanRequestBody,
    {},
    {},
    ExecuteBranchMigrationPlanPathParams
  >({ url: '/db/{dbBranchName}/migrations/execute', method: 'post', ...variables });

export type GetBranchMigrationPlanPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchMigrationPlanError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchMigrationPlanVariables = {
  body: Schemas.Schema;
  pathParams: GetBranchMigrationPlanPathParams;
} & FetcherExtraProps;

/**
 * Compute a migration plan from a target schema the branch should be migrated too.
 */
export const getBranchMigrationPlan = (variables: GetBranchMigrationPlanVariables) =>
  fetch<
    Responses.BranchMigrationPlan,
    GetBranchMigrationPlanError,
    Schemas.Schema,
    {},
    {},
    GetBranchMigrationPlanPathParams
  >({ url: '/db/{dbBranchName}/migrations/plan', method: 'post', ...variables });

export type GetBranchStatsPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type GetBranchStatsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.SimpleError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetBranchStatsResponse = {
  timestamp: string;
  interval: string;
  resolution: string;
  numberOfRecords?: Schemas.MetricsDatapoint[];
  writesOverTime?: Schemas.MetricsDatapoint[];
  readsOverTime?: Schemas.MetricsDatapoint[];
  readLatency?: Schemas.MetricsLatency;
  writeLatency?: Schemas.MetricsLatency;
  warning?: string;
};

export type GetBranchStatsVariables = {
  pathParams: GetBranchStatsPathParams;
} & FetcherExtraProps;

/**
 * Get branch usage metrics.
 */
export const getBranchStats = (variables: GetBranchStatsVariables) =>
  fetch<GetBranchStatsResponse, GetBranchStatsError, undefined, {}, {}, GetBranchStatsPathParams>({
    url: '/db/{dbBranchName}/stats',
    method: 'get',
    ...variables
  });

export type CreateTablePathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type CreateTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type CreateTableResponse = {
  branchName: string;
  /*
   * @minLength 1
   */
  tableName: string;
};

export type CreateTableVariables = {
  pathParams: CreateTablePathParams;
} & FetcherExtraProps;

/**
 * Creates a new table with the given name. Returns 422 if a table with the same name already exists.
 */
export const createTable = (variables: CreateTableVariables) =>
  fetch<CreateTableResponse, CreateTableError, undefined, {}, {}, CreateTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}',
    method: 'put',
    ...variables
  });

export type DeleteTablePathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type DeleteTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
>;

export type DeleteTableVariables = {
  pathParams: DeleteTablePathParams;
} & FetcherExtraProps;

/**
 * Deletes the table with the given name.
 */
export const deleteTable = (variables: DeleteTableVariables) =>
  fetch<undefined, DeleteTableError, undefined, {}, {}, DeleteTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}',
    method: 'delete',
    ...variables
  });

export type UpdateTablePathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type UpdateTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateTableRequestBody = {
  /*
   * @minLength 1
   */
  name: string;
};

export type UpdateTableVariables = {
  body: UpdateTableRequestBody;
  pathParams: UpdateTablePathParams;
} & FetcherExtraProps;

/**
 * Update table. Currently there is only one update operation supported: renaming the table by providing a new name.
 *
 * In the example below, we rename a table from “users” to “people”:
 *
 * ```json
 * // PATCH /db/test:main/tables/users
 *
 * {
 *   "name": "people"
 * }
 * ```
 */
export const updateTable = (variables: UpdateTableVariables) =>
  fetch<undefined, UpdateTableError, UpdateTableRequestBody, {}, {}, UpdateTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}',
    method: 'patch',
    ...variables
  });

export type GetTableSchemaPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type GetTableSchemaError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetTableSchemaResponse = {
  columns: Schemas.Column[];
};

export type GetTableSchemaVariables = {
  pathParams: GetTableSchemaPathParams;
} & FetcherExtraProps;

export const getTableSchema = (variables: GetTableSchemaVariables) =>
  fetch<GetTableSchemaResponse, GetTableSchemaError, undefined, {}, {}, GetTableSchemaPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/schema',
    method: 'get',
    ...variables
  });

export type SetTableSchemaPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type SetTableSchemaError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 409;
      payload: Responses.SimpleError;
    }
>;

export type SetTableSchemaRequestBody = {
  columns: Schemas.Column[];
};

export type SetTableSchemaVariables = {
  body: SetTableSchemaRequestBody;
  pathParams: SetTableSchemaPathParams;
} & FetcherExtraProps;

export const setTableSchema = (variables: SetTableSchemaVariables) =>
  fetch<undefined, SetTableSchemaError, SetTableSchemaRequestBody, {}, {}, SetTableSchemaPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/schema',
    method: 'put',
    ...variables
  });

export type GetTableColumnsPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type GetTableColumnsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetTableColumnsResponse = {
  columns: Schemas.Column[];
};

export type GetTableColumnsVariables = {
  pathParams: GetTableColumnsPathParams;
} & FetcherExtraProps;

/**
 * Retrieves the list of table columns and their definition. This endpoint returns the column list with object columns being reported with their
 * full dot-separated path (flattened).
 */
export const getTableColumns = (variables: GetTableColumnsVariables) =>
  fetch<GetTableColumnsResponse, GetTableColumnsError, undefined, {}, {}, GetTableColumnsPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns',
    method: 'get',
    ...variables
  });

export type AddTableColumnPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type AddTableColumnError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type AddTableColumnVariables = {
  body: Schemas.Column;
  pathParams: AddTableColumnPathParams;
} & FetcherExtraProps;

/**
 * Adds a new column to the table. The body of the request should contain the column definition. In the column definition, the 'name' field should
 * contain the full path separated by dots. If the parent objects do not exists, they will be automatically created. For example,
 * passing `"name": "address.city"` will auto-create the `address` object if it doesn't exist.
 */
export const addTableColumn = (variables: AddTableColumnVariables) =>
  fetch<Responses.MigrationIdResponse, AddTableColumnError, Schemas.Column, {}, {}, AddTableColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns',
    method: 'post',
    ...variables
  });

export type GetColumnPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Column name
   */
  columnName: Schemas.ColumnName;
  workspace: string;
};

export type GetColumnError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetColumnVariables = {
  pathParams: GetColumnPathParams;
} & FetcherExtraProps;

/**
 * Get the definition of a single column. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
export const getColumn = (variables: GetColumnVariables) =>
  fetch<Schemas.Column, GetColumnError, undefined, {}, {}, GetColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',
    method: 'get',
    ...variables
  });

export type DeleteColumnPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Column name
   */
  columnName: Schemas.ColumnName;
  workspace: string;
};

export type DeleteColumnError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteColumnVariables = {
  pathParams: DeleteColumnPathParams;
} & FetcherExtraProps;

/**
 * Deletes the specified column. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
export const deleteColumn = (variables: DeleteColumnVariables) =>
  fetch<Responses.MigrationIdResponse, DeleteColumnError, undefined, {}, {}, DeleteColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',
    method: 'delete',
    ...variables
  });

export type UpdateColumnPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Column name
   */
  columnName: Schemas.ColumnName;
  workspace: string;
};

export type UpdateColumnError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type UpdateColumnRequestBody = {
  /*
   * @minLength 1
   */
  name: string;
};

export type UpdateColumnVariables = {
  body: UpdateColumnRequestBody;
  pathParams: UpdateColumnPathParams;
} & FetcherExtraProps;

/**
 * Update column with partial data. Can be used for renaming the column by providing a new "name" field. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
export const updateColumn = (variables: UpdateColumnVariables) =>
  fetch<Responses.MigrationIdResponse, UpdateColumnError, UpdateColumnRequestBody, {}, {}, UpdateColumnPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',
    method: 'patch',
    ...variables
  });

export type InsertRecordPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type InsertRecordQueryParams = {
  /*
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
};

export type InsertRecordError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type InsertRecordVariables = {
  body?: Record<string, any>;
  pathParams: InsertRecordPathParams;
  queryParams?: InsertRecordQueryParams;
} & FetcherExtraProps;

/**
 * Insert a new Record into the Table
 */
export const insertRecord = (variables: InsertRecordVariables) =>
  fetch<
    Responses.RecordUpdateResponse,
    InsertRecordError,
    Record<string, any>,
    {},
    InsertRecordQueryParams,
    InsertRecordPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data', method: 'post', ...variables });

export type InsertRecordWithIDPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type InsertRecordWithIDQueryParams = {
  /*
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
  createOnly?: boolean;
  ifVersion?: number;
};

export type InsertRecordWithIDError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type InsertRecordWithIDVariables = {
  body?: Record<string, any>;
  pathParams: InsertRecordWithIDPathParams;
  queryParams?: InsertRecordWithIDQueryParams;
} & FetcherExtraProps;

/**
 * By default, IDs are auto-generated when data is insterted into Xata. Sending a request to this endpoint allows us to insert a record with a pre-existing ID, bypassing the default automatic ID generation.
 */
export const insertRecordWithID = (variables: InsertRecordWithIDVariables) =>
  fetch<
    Responses.RecordUpdateResponse,
    InsertRecordWithIDError,
    Record<string, any>,
    {},
    InsertRecordWithIDQueryParams,
    InsertRecordWithIDPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'put', ...variables });

export type UpdateRecordWithIDPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type UpdateRecordWithIDQueryParams = {
  /*
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
  ifVersion?: number;
};

export type UpdateRecordWithIDError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type UpdateRecordWithIDVariables = {
  body?: Record<string, any>;
  pathParams: UpdateRecordWithIDPathParams;
  queryParams?: UpdateRecordWithIDQueryParams;
} & FetcherExtraProps;

export const updateRecordWithID = (variables: UpdateRecordWithIDVariables) =>
  fetch<
    Responses.RecordUpdateResponse,
    UpdateRecordWithIDError,
    Record<string, any>,
    {},
    UpdateRecordWithIDQueryParams,
    UpdateRecordWithIDPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'patch', ...variables });

export type UpsertRecordWithIDPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type UpsertRecordWithIDQueryParams = {
  /*
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
  ifVersion?: number;
};

export type UpsertRecordWithIDError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type UpsertRecordWithIDVariables = {
  body?: Record<string, any>;
  pathParams: UpsertRecordWithIDPathParams;
  queryParams?: UpsertRecordWithIDQueryParams;
} & FetcherExtraProps;

export const upsertRecordWithID = (variables: UpsertRecordWithIDVariables) =>
  fetch<
    Responses.RecordUpdateResponse,
    UpsertRecordWithIDError,
    Record<string, any>,
    {},
    UpsertRecordWithIDQueryParams,
    UpsertRecordWithIDPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}', method: 'post', ...variables });

export type DeleteRecordPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type DeleteRecordQueryParams = {
  /*
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
};

export type DeleteRecordError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type DeleteRecordVariables = {
  pathParams: DeleteRecordPathParams;
  queryParams?: DeleteRecordQueryParams;
} & FetcherExtraProps;

export const deleteRecord = (variables: DeleteRecordVariables) =>
  fetch<Responses.RecordResponse, DeleteRecordError, undefined, {}, DeleteRecordQueryParams, DeleteRecordPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',
    method: 'delete',
    ...variables
  });

export type GetRecordPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  /*
   * The Record name
   */
  recordId: Schemas.RecordID;
  workspace: string;
};

export type GetRecordQueryParams = {
  /*
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
};

export type GetRecordError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type GetRecordVariables = {
  pathParams: GetRecordPathParams;
  queryParams?: GetRecordQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve record by ID
 */
export const getRecord = (variables: GetRecordVariables) =>
  fetch<Responses.RecordResponse, GetRecordError, undefined, {}, GetRecordQueryParams, GetRecordPathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',
    method: 'get',
    ...variables
  });

export type BulkInsertTableRecordsPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type BulkInsertTableRecordsQueryParams = {
  /*
   * Column filters
   */
  columns?: Schemas.ColumnsProjection;
};

export type BulkInsertTableRecordsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BulkError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
  | {
      status: 422;
      payload: Responses.SimpleError;
    }
>;

export type BulkInsertTableRecordsRequestBody = {
  records: Record<string, any>[];
};

export type BulkInsertTableRecordsVariables = {
  body: BulkInsertTableRecordsRequestBody;
  pathParams: BulkInsertTableRecordsPathParams;
  queryParams?: BulkInsertTableRecordsQueryParams;
} & FetcherExtraProps;

/**
 * Bulk insert records
 */
export const bulkInsertTableRecords = (variables: BulkInsertTableRecordsVariables) =>
  fetch<
    Responses.BulkInsertResponse,
    BulkInsertTableRecordsError,
    BulkInsertTableRecordsRequestBody,
    {},
    BulkInsertTableRecordsQueryParams,
    BulkInsertTableRecordsPathParams
  >({ url: '/db/{dbBranchName}/tables/{tableName}/bulk', method: 'post', ...variables });

export type QueryTablePathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type QueryTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type QueryTableRequestBody = {
  filter?: Schemas.FilterExpression;
  sort?: Schemas.SortExpression;
  page?: Schemas.PageConfig;
  columns?: Schemas.ColumnsProjection;
};

export type QueryTableVariables = {
  body?: QueryTableRequestBody;
  pathParams: QueryTablePathParams;
} & FetcherExtraProps;

/**
 * The Query Table API can be used to retrieve all records in a table.
 * The API support filtering, sorting, selecting a subset of columns, and pagination.
 *
 * The overall structure of the request looks like this:
 *
 * ```json
 * // POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [...],
 *   "filter": {
 *     "$all": [...],
 *     "$any": [...]
 *     ...
 *   },
 *   "sort": {
 *     "multiple": [...]
 *     ...
 *   },
 *   "page": {
 *     ...
 *   }
 * }
 * ```
 *
 * ### Column selection
 *
 * If the `columns` array is not specified, all columns are included. For link
 * fields, only the ID column of the linked records is included in the response.
 *
 * If the `columns` array is specified, only the selected columns are included.
 * The `*` wildcard can be used to select all columns of the given array
 *
 * For objects and link fields, if the column name of the object is specified, we
 * include all of its sub-keys. If only some sub-keys are specified (via dotted
 * notation, e.g. `"settings.plan"` ), then only those sub-keys from the object
 * are included.
 *
 * By the way of example, assuming two tables like this:
 *
 * ```json {"truncate": true}
 * {
 *   "formatVersion": "1.0",
 *   "tables": [
 *     {
 *       "name": "teams",
 *       "columns": [
 *         {
 *           "name": "name",
 *           "type": "string"
 *         },
 *         {
 *           "name": "owner",
 *           "type": "link",
 *           "link": {
 *             "table": "users"
 *           }
 *         },
 *         {
 *           "name": "foundedDate",
 *           "type": "datetime"
 *         },
 *       ]
 *     },
 *     {
 *       "name": "users",
 *       "columns": [
 *         {
 *           "name": "email",
 *           "type": "email"
 *         },
 *         {
 *           "name": "full_name",
 *           "type": "string"
 *         },
 *         {
 *           "name": "address",
 *           "type": "object",
 *           "columns": [
 *             {
 *               "name": "street",
 *               "type": "string"
 *             },
 *             {
 *               "name": "number",
 *               "type": "int"
 *             },
 *             {
 *               "name": "zipcode",
 *               "type": "int"
 *             }
 *           ]
 *         },
 *         {
 *           "name": "team",
 *           "type": "link",
 *           "link": {
 *             "table": "teams"
 *           }
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * A query like this:
 *
 * ```json
 * POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [
 *     "name",
 *     "address.*"
 *   ]
 * }
 * ```
 *
 * returns objects like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   }
 * }
 * ```
 *
 * while a query like this:
 *
 * ```json
 * POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [
 *     "name",
 *     "address.street"
 *   ]
 * }
 * ```
 *
 * returns objects like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "address": {
 *     "street": "New street"
 *   }
 * }
 * ```
 *
 * If you want to return all columns from the main table and selected columns from the linked table, you can do it like this:
 *
 * ```json
 * {
 *   "columns": ["*", "team.name"]
 * }
 * ```
 *
 * The `"*"` in the above means all columns, including columns of objects. This returns data like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "email": "kilian@gmail.com",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   },
 *   "team": {
 *     "id": "XX",
 *     "xata": {
 *       "version": 0
 *     },
 *     "name": "first team"
 *   }
 * }
 * ```
 *
 * If you want all columns of the linked table, you can do:
 *
 * ```json
 * {
 *   "columns": ["*", "team.*"]
 * }
 * ```
 *
 * This returns, for example:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "email": "kilian@gmail.com",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   },
 *   "team": {
 *     "id": "XX",
 *     "xata": {
 *       "version": 0
 *     },
 *     "name": "first team",
 *     "code": "A1",
 *     "foundedDate": "2020-03-04T10:43:54.32Z"
 *   }
 * }
 * ```
 *
 * ### Filtering
 *
 * There are two types of operators:
 *
 * - Operators that work on a single column: `$is`, `$contains`, `$pattern`,
 *   `$includes`, `$gt`, etc.
 * - Control operators that combine multiple conditions: `$any`, `$all`, `$not` ,
 *   `$none`, etc.
 *
 * All operators start with an `$` to differentiate them from column names
 * (which are not allowed to start with a dollar sign).
 *
 * #### Exact matching and control operators
 *
 * Filter by one column:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": "value"
 *   }
 * }
 * ```
 *
 * This is equivalent to using the `$is` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$is": "value"
 *     }
 *   }
 * }
 * ```
 *
 * For example:
 *
 * ```json
 * {
 *   "filter": {
 *     "name": "r2"
 *   }
 * }
 * ```
 *
 * Or:
 *
 * ```json
 * {
 *   "filter": {
 *     "name": {
 *       "$is": "r2"
 *     }
 *   }
 * }
 * ```
 *
 * For objects, both dots and nested versions work:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.plan": "free"
 *   }
 * }
 * ```
 *
 * ```json
 * {
 *   "filter": {
 *     "settings": {
 *       "plan": "free"
 *     }
 *   }
 * }
 * ```
 *
 * If you want to OR together multiple values, you can use the `$any` operator with an array of values:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.plan": { "$any": ["free", "paid"] }
 *   }
 * }
 * ```
 *
 * If you specify multiple columns in the same filter, they are logically AND'ed together:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.dark": true,
 *     "settings.plan": "free"
 *   }
 * }
 * ```
 *
 * The above matches if both conditions are met.
 *
 * To be more explicit about it, you can use `$all` or `$any`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$any": {
 *       "settings.dark": true,
 *       "settings.plan": "free"
 *     }
 *   }
 * }
 * ```
 *
 * The `$all` and `$any` operators can also receive an array of objects, which allows for repeating column names:
 *
 * ```json
 * {
 *   "filter": {
 *     "$any": [
 *       {
 *         "name": "r1"
 *       },
 *       {
 *         "name": "r2"
 *       }
 *     ]
 *   }
 * }
 * ```
 *
 * You can check for a value being not-null with `$exists`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$exists": "settings"
 *   }
 * }
 * ```
 *
 * This can be combined with `$all` or `$any` :
 *
 * ```json
 * {
 *   "filter": {
 *     "$all": [
 *       {
 *         "$exists": "settings"
 *       },
 *       {
 *         "$exists": "name"
 *       }
 *     ]
 *   }
 * }
 * ```
 *
 * Or you can use the inverse operator `$notExists`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$notExists": "settings"
 *   }
 * }
 * ```
 *
 * #### Partial match
 *
 * `$contains` is the simplest operator for partial matching. We should generally
 * discourage overusing `$contains` because it typically can't make use of
 * indices.
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$contains": "value"
 *     }
 *   }
 * }
 * ```
 *
 * Wildcards are supported via the `$pattern` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$pattern": "v*alu?"
 *     }
 *   }
 * }
 * ```
 *
 * The `$pattern` operator accepts two wildcard characters:
 * * `*` matches zero or more characters
 * * `?` matches exactly one character
 *
 * If you want to match a string that contains a wildcard character, you can escape them using a backslash (`\`). You can escape a backslash by usign another backslash.
 *
 * We could also have `$endsWith` and `$startsWith` operators:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$endsWith": ".gz"
 *     },
 *     "<column_name>": {
 *       "$startsWith": "tmp-"
 *     }
 *   }
 * }
 * ```
 *
 * #### Numeric or datetime ranges
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$ge": 0,
 *       "$lt": 100
 *     }
 *   }
 * }
 * ```
 * Date ranges support the same operators, with the date using the format defined in
 * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339):
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$gt": "2019-10-12T07:20:50.52Z",
 *       "$lt": "2021-10-12T07:20:50.52Z"
 *     }
 *   }
 * }
 * ```
 * The supported operators are `$gt`, `$lt`, `$ge`, `$le`.
 *
 * #### Negations
 *
 * A general `$not` operator can inverse any operation.
 *
 * ```json
 * {
 *   "filter": {
 *     "$not": {
 *       "<column_name1>": "value1",
 *       "<column_name2>": "value1"
 *     }
 *   }
 * }
 * ```
 *
 * Note: in the above the two condition are AND together, so this does (NOT ( ...
 * AND ...))
 *
 * Or more complex:
 *
 * ```json
 * {
 *   "filter": {
 *     "$not": {
 *       "$any": [
 *         {
 *           "<column_name1>": "value1"
 *         },
 *         {
 *           "$all": [
 *             {
 *               "<column_name2>": "value2"
 *             },
 *             {
 *               "<column_name3>": "value3"
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   }
 * }
 * ```
 *
 * The `$not: { $any: {}}` can be shorted using the `$none` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "$none": {
 *       "<column_name1>": "value1",
 *       "<column_name2>": "value1"
 *     }
 *   }
 * }
 * ```
 *
 * In addition, you can use operators like `$isNot` or `$notExists` to simplify expressions:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$isNot": "2019-10-12T07:20:50.52Z"
 *     }
 *   }
 * }
 * ```
 *
 * #### Working with arrays
 *
 * To test that an array contains a value, use `$includes`.
 *
 * ```json
 * {
 *   "filter": {
 *     "<array_name>": {
 *       "$includes": "value"
 *     }
 *   }
 * }
 * ```
 *
 * The `$includes` operator accepts a custom predicate that will check if any
 * array values matches the predicate. For example a complex predicate can include
 * the `$all` , `$contains` and `$endsWith` operators:
 *
 * ```json
 * {
 *   "filter": {
 *     "<array name>": {
 *       "$includes": {
 *         "$all": [
 *           { "$contains": "label" },
 *           { "$not": { "$endsWith": "-debug" } }
 *         ]
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * The `$includes` all operator succeeds if any column in the array matches the
 * predicate. The `$includesAll` operator succeeds if all array items match the
 * predicate. The `$includesNone` operator succeeds if no array item matches the
 * predicate. The `$includes` operator is a synonym for the `$includesAny`
 * operator.
 *
 * Here is an example of using the `$includesAll` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.labels": {
 *       "$includesAll": [{ "$contains": "label" }]
 *     }
 *   }
 * }
 * ```
 *
 * The above matches if all label values contain the string "labels".
 *
 * ### Sorting
 *
 * Sorting by one element:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": {
 *     "index": "asc"
 *   }
 * }
 * ```
 *
 * or descendently:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": {
 *     "index": "desc"
 *   }
 * }
 * ```
 *
 * Sorting by multiple fields:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": [
 *     {
 *       "index": "desc"
 *     },
 *     {
 *       "createdAt": "desc"
 *     }
 *   ]
 * }
 * ```
 *
 * ### Pagination
 *
 * We offer cursor pagination and offset pagination. The offset pagination is limited
 * in the amount of data it can retrieve, so we recommend the cursor pagination if you have more than 1000 records.
 *
 * Example of size + offset pagination:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "size": 100,
 *     "offset": 200
 *   }
 * }
 * ```
 *
 * The `page.size` parameter represents the maximum number of records returned by this query. It has a default value of 20 and a maximum value of 200.
 * The `page.offset` parameter represents the number of matching records to skip. It has a default value of 0 and a maximum value of 800.
 *
 * Example of cursor pagination:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "after":"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD"
 *   }
 * }
 * ```
 *
 * In the above example, the value of the `page.after` parameter is the cursor returned by the previous query. A sample response is shown below:
 *
 * ```json
 * {
 *   "meta": {
 *     "page": {
 *       "cursor": "fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD",
 *       "more": true
 *     }
 *   },
 *   "records": [...]
 * }
 * ```
 *
 * The `page` object might contain the follow keys, in addition to `size` and `offset` that were introduced before:
 *
 * - `after`: Return the next page 'after' the current cursor
 * - `before`: Return the previous page 'before' the current cursor.
 * - `first`: Return the first page in the table from a cursor.
 * - `last`: Return the last N records in the table from a cursor, where N is the `page.size` parameter.
 *
 * The request will fail if an invalid cursor value is given to `page.before`,
 * `page.after`, `page.first` , or `page.last`. No other cursor setting can be
 * used if `page.first` or `page.last` is set in a query.
 *
 * If both `page.before` and `page.after` parameters are present we treat the
 * request as a range query. The range query will return all entries after
 * `page.after`, but before `page.before`, up to `page.size` or the maximum
 * page size. This query requires both cursors to use the same filters and sort
 * settings, plus we require `page.after < page.before`. The range query returns
 * a new cursor. If the range encompass multiple pages the next page in the range
 * can be queried by update `page.after` to the returned cursor while keeping the
 * `page.before` cursor from the first range query.
 *
 * The `filter` , `columns`, `sort` , and `page.size` configuration will be
 * encoded with the cursor. The pagination request will be invalid if
 * `filter` or `sort` is set. The columns returned and page size can be changed
 * anytime by passing the `columns` or `page.size` settings to the next query.
 *
 * **Special cursors:**
 *
 * - `page.after=end`: Result points past the last entry. The list of records
 *   returned is empty, but `page.meta.cursor` will include a cursor that can be
 *   used to "tail" the table from the end waiting for new data to be inserted.
 * - `page.before=end`: This cursor returns the last page.
 * - `page.first=<cursor>`: Go to first page. This is equivalent to querying the
 *   first page without a cursor but `filter` and `sort` . Yet the `page.first`
 *   cursor can be convenient at times as user code does not need to remember the
 *   filter, sort, columns or page size configuration. All these information are
 *   read from the cursor.
 * - `page.last=<cursor>`: Go to the end of the table. This is equivalent to querying the
 *   last page with `page.before=end`, `filter`, and `sort` . Yet the
 *   `page.last` cursor can be more convenient at times as user code does not
 *   need to remember the filter, sort, columns or page size configuration. All
 *   these information are read from the cursor.
 *
 * When using special cursors like `page.after="end"` or `page.before="end"`, we
 * still allow `filter` and `sort` to be set.
 *
 * Example of getting the last page:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "size": 10,
 *     "before": "end"
 *   }
 * }
 * ```
 */
export const queryTable = (variables: QueryTableVariables) =>
  fetch<Responses.QueryResponse, QueryTableError, QueryTableRequestBody, {}, {}, QueryTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/query',
    method: 'post',
    ...variables
  });

export type SearchTablePathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  /*
   * The Table name
   */
  tableName: Schemas.TableName;
  workspace: string;
};

export type SearchTableError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type SearchTableRequestBody = {
  /*
   * The query string.
   *
   * @minLength 1
   */
  query: string;
  fuzziness?: Schemas.FuzzinessExpression;
  prefix?: Schemas.PrefixExpression;
  filter?: Schemas.FilterExpression;
  highlight?: Schemas.HighlightExpression;
  boosters?: Schemas.BoosterExpression[];
};

export type SearchTableVariables = {
  body: SearchTableRequestBody;
  pathParams: SearchTablePathParams;
} & FetcherExtraProps;

/**
 * Run a free text search operation in a particular table.
 *
 * The endpoint accepts a `query` parameter that is used for the free text search and a set of structured filters (via the `filter` parameter) that are applied before the search. The `filter` parameter uses the same syntax as the [query endpoint](/api-reference/db/db_branch_name/tables/table_name/) with the following exceptions:
 * * filters `$contains`, `$startsWith`, `$endsWith` don't work on columns of type `text`
 * * filtering on columns of type `multiple` is currently unsupported
 */
export const searchTable = (variables: SearchTableVariables) =>
  fetch<Responses.SearchResponse, SearchTableError, SearchTableRequestBody, {}, {}, SearchTablePathParams>({
    url: '/db/{dbBranchName}/tables/{tableName}/search',
    method: 'post',
    ...variables
  });

export type SearchBranchPathParams = {
  /*
   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
   */
  dbBranchName: Schemas.DBBranchName;
  workspace: string;
};

export type SearchBranchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.BadRequestError;
    }
  | {
      status: 401;
      payload: Responses.AuthError;
    }
  | {
      status: 404;
      payload: Responses.SimpleError;
    }
>;

export type SearchBranchRequestBody = {
  /*
   * An array with the tables in which to search. By default, all tables are included. Optionally, filters can be included that apply to each table.
   */
  tables?: (
    | string
    | {
        /*
         * The name of the table.
         */
        table: string;
        filter?: Schemas.FilterExpression;
        boosters?: Schemas.BoosterExpression[];
      }
  )[];
  /*
   * The query string.
   *
   * @minLength 1
   */
  query: string;
  fuzziness?: Schemas.FuzzinessExpression;
  highlight?: Schemas.HighlightExpression;
};

export type SearchBranchVariables = {
  body: SearchBranchRequestBody;
  pathParams: SearchBranchPathParams;
} & FetcherExtraProps;

/**
 * Run a free text search operation across the database branch.
 */
export const searchBranch = (variables: SearchBranchVariables) =>
  fetch<Responses.SearchResponse, SearchBranchError, SearchBranchRequestBody, {}, {}, SearchBranchPathParams>({
    url: '/db/{dbBranchName}/search',
    method: 'post',
    ...variables
  });

export const operationsByTag = {
  users: { getUser, updateUser, deleteUser, getUserAPIKeys, createUserAPIKey, deleteUserAPIKey },
  workspaces: {
    createWorkspace,
    getWorkspacesList,
    getWorkspace,
    updateWorkspace,
    deleteWorkspace,
    getWorkspaceMembersList,
    updateWorkspaceMemberRole,
    removeWorkspaceMember,
    inviteWorkspaceMember,
    updateWorkspaceMemberInvite,
    cancelWorkspaceMemberInvite,
    resendWorkspaceMemberInvite,
    acceptWorkspaceMemberInvite
  },
  database: {
    getDatabaseList,
    createDatabase,
    deleteDatabase,
    getGitBranchesMapping,
    addGitBranchesEntry,
    removeGitBranchesEntry,
    resolveBranch
  },
  branch: {
    getBranchList,
    getDatabaseMetadata,
    getBranchDetails,
    createBranch,
    deleteBranch,
    updateBranchMetadata,
    getBranchMetadata,
    getBranchMigrationHistory,
    executeBranchMigrationPlan,
    getBranchMigrationPlan,
    getBranchStats
  },
  table: {
    createTable,
    deleteTable,
    updateTable,
    getTableSchema,
    setTableSchema,
    getTableColumns,
    addTableColumn,
    getColumn,
    deleteColumn,
    updateColumn
  },
  records: {
    insertRecord,
    insertRecordWithID,
    updateRecordWithID,
    upsertRecordWithID,
    deleteRecord,
    getRecord,
    bulkInsertTableRecords,
    queryTable,
    searchTable,
    searchBranch
  }
};
